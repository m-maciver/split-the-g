<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="theme-color" content="#0B1A0E">
  <meta name="description" content="1v1 competitive Guinness challenge. Snap your pint, split the G, and prove you pour the perfect drink. Play with friends in real-time.">

  <!-- Open Graph / Facebook -->
  <meta property="og:type" content="website">
  <meta property="og:url" content="https://split-the-g-production.up.railway.app/">
  <meta property="og:title" content="SPLIT IT — 1v1 Pub Challenge">
  <meta property="og:description" content="Think you can split the G? Challenge your mates to a 1v1 Guinness showdown. Snap, drink, prove it.">
  <meta property="og:image" content="https://split-the-g-production.up.railway.app/og-image.svg">
  <meta property="og:image:width" content="1200">
  <meta property="og:image:height" content="630">

  <!-- Twitter -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="SPLIT IT — 1v1 Pub Challenge">
  <meta name="twitter:description" content="Think you can split the G? Challenge your mates to a 1v1 Guinness showdown.">
  <meta name="twitter:image" content="https://split-the-g-production.up.railway.app/og-image.svg">

  <link rel="manifest" href="manifest.json">
  <link rel="apple-touch-icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 180 180'%3E%3Crect width='180' height='180' rx='30' fill='%230B1A0E'/%3E%3Ctext x='90' y='120' font-size='90' text-anchor='middle' fill='%23D4A843' font-family='system-ui' font-weight='900'%3EI%3C/text%3E%3C/svg%3E">
  <title>SPLIT IT — 1v1 Pub Challenge</title>
  <script>
    // Register service worker for offline support
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('/sw.js')
          .then(reg => console.log('[SW] Registered:', reg.scope))
          .catch(err => console.log('[SW] Registration failed:', err));
      });
    }
  </script>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://unpkg.com/framer-motion@10/dist/framer-motion.js"></script>
  <script src="/socket.io/socket.io.js"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=DM+Sans:wght@400;500;600;700;800;900&family=Space+Mono:wght@400;700&display=swap');

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }

    :root {
      --bg-primary: #0B1A0E;
      --bg-elevated: #132A18;
      --bg-surface: #1A3520;
      --cream: #F5E6C8;
      --gold: #D4A843;
      --emerald: #34D399;
      --text-primary: #F0EBE0;
      --text-secondary: #7C9A82;
      --accent-red: #EF4444;
      --border: rgba(212,168,67,0.12);
      --glow: rgba(52,211,153,0.15);
    }

    @property --border-angle {
      syntax: '<angle>';
      initial-value: 0deg;
      inherits: false;
    }

    html {
      height: -webkit-fill-available;
    }

    body {
      font-family: 'DM Sans', sans-serif;
      -webkit-user-select: none;
      user-select: none;
      background: var(--bg-primary);
      color: var(--text-primary);
      overflow-x: hidden;
      min-height: 100vh;
      min-height: -webkit-fill-available;
    }

    .safe-top { padding-top: max(env(safe-area-inset-top), 16px); }
    .safe-bottom { padding-bottom: max(env(safe-area-inset-bottom), 24px); }

    /* ---- Buttons ---- */
    .btn-primary {
      background: linear-gradient(135deg, #D4A843, #E0BE6A);
      color: #0B1A0E;
      border: none;
      border-radius: 14px;
      height: 56px;
      width: 100%;
      font-family: 'DM Sans', sans-serif;
      font-weight: 700;
      font-size: 16px;
      cursor: pointer;
      transition: opacity 0.15s ease, transform 0.1s ease, box-shadow 0.15s ease;
    }
    .btn-primary:active { transform: scale(0.98); box-shadow: 0 0 24px rgba(212,168,67,0.5); }
    .btn-primary:disabled { opacity: 0.4; cursor: not-allowed; }

    .btn-primary-light {
      background: var(--cream);
      color: #0B1A0E;
      border: none;
      border-radius: 14px;
      height: 56px;
      width: 100%;
      font-family: 'DM Sans', sans-serif;
      font-weight: 700;
      font-size: 16px;
      cursor: pointer;
      transition: opacity 0.15s ease, transform 0.1s ease;
    }
    .btn-primary-light:active { transform: scale(0.98); opacity: 0.9; }
    .btn-primary-light:disabled { opacity: 0.4; cursor: not-allowed; }

    .btn-success {
      background: linear-gradient(135deg, #34D399, #4AE8AF);
      color: #fff;
      border: none;
      border-radius: 14px;
      height: 56px;
      width: 100%;
      font-family: 'DM Sans', sans-serif;
      font-weight: 700;
      font-size: 16px;
      cursor: pointer;
      transition: opacity 0.15s ease, transform 0.1s ease, box-shadow 0.15s ease;
    }
    .btn-success:active { transform: scale(0.98); box-shadow: 0 0 24px rgba(52,211,153,0.5); }

    .btn-text {
      background: none;
      border: 1px solid transparent;
      border-radius: 8px;
      color: var(--cream);
      font-family: 'DM Sans', sans-serif;
      font-weight: 500;
      font-size: 14px;
      cursor: pointer;
      padding: 8px 16px;
      transition: border-color 0.15s ease;
    }
    .btn-text:hover { border-color: var(--gold); }

    /* ---- Focus styles for accessibility ---- */
    .btn-primary:focus-visible, .btn-primary-light:focus-visible, .btn-success:focus-visible, .btn-text:focus-visible {
      outline: 2px solid var(--gold);
      outline-offset: 2px;
    }
    button:focus-visible { outline: 2px solid var(--gold); outline-offset: 2px; }
    /* Skip link for keyboard users */
    .skip-link {
      position: absolute;
      top: -40px;
      left: 0;
      background: var(--gold);
      color: var(--bg-primary);
      padding: 8px 16px;
      z-index: 100;
      font-weight: 700;
      border-radius: 0 0 8px 0;
    }
    .skip-link:focus { top: 0; }

    /* ---- Typography ---- */
    .t-hero { font-family: 'Space Mono', monospace; font-size: 80px; font-weight: 700; font-variant-numeric: tabular-nums; line-height: 1; }
    .t-title { font-size: 24px; font-weight: 700; }
    .t-body { font-size: 16px; font-weight: 500; }
    .t-label { font-size: 11px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.1em; color: var(--gold); }
    .t-small { font-size: 14px; font-weight: 400; color: var(--text-secondary); }

    /* ---- Cards ---- */
    .card {
      border-radius: 16px;
      padding: 20px;
      border: 1px solid var(--border);
      background: rgba(26,53,32,0.6);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
    }
    .card-dark {
      border-radius: 16px;
      padding: 20px;
      border: 1px solid var(--border);
      background: rgba(26,53,32,0.6);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
    }

    /* ---- Layout ---- */
    .layout {
      max-width: 400px;
      margin: 0 auto;
      padding: 0 24px;
      width: 100%;
    }

    /* ---- Pulsing dots ---- */
    .pulsing-dots { display: flex; gap: 6px; align-items: center; justify-content: center; }
    .pulsing-dots span {
      width: 8px; height: 8px; border-radius: 50%;
      background: var(--emerald);
      animation: dot-pulse 1.4s ease-in-out infinite;
    }
    .pulsing-dots span:nth-child(2) { animation-delay: 0.2s; }
    .pulsing-dots span:nth-child(3) { animation-delay: 0.4s; }
    @keyframes dot-pulse {
      0%, 80%, 100% { opacity: 0.3; transform: scale(0.8); }
      40% { opacity: 1; transform: scale(1); }
    }

    .pulsing-dots-light span { background: var(--emerald); }

    /* ---- Scan line ---- */
    .scan-line {
      position: absolute;
      left: 0; right: 0; height: 3px;
      background: linear-gradient(90deg, transparent, var(--emerald), transparent);
      box-shadow: 0 0 20px var(--emerald);
      animation: scan-anim 1.8s ease-in-out;
    }
    @keyframes scan-anim {
      0% { top: 0%; opacity: 0; }
      10% { opacity: 1; }
      90% { opacity: 1; }
      100% { top: 100%; opacity: 0; }
    }

    /* ---- Confetti ---- */
    .confetti-particle {
      position: fixed;
      width: 8px; height: 8px;
      border-radius: 2px;
      animation: confetti-fall 2s ease-out forwards;
      z-index: 100;
    }
    @keyframes confetti-fall {
      0% { transform: translateY(0) rotate(0deg); opacity: 1; }
      100% { transform: translateY(100vh) rotate(720deg); opacity: 0; }
    }

    /* ---- Shutter button ---- */
    .shutter-btn {
      width: 72px; height: 72px;
      border-radius: 50%;
      border: 4px solid var(--gold);
      background: transparent;
      display: flex; align-items: center; justify-content: center;
      cursor: pointer;
      transition: transform 0.1s, box-shadow 0.15s;
    }
    .shutter-btn:active { transform: scale(0.92); box-shadow: 0 0 24px rgba(212,168,67,0.5); }
    .shutter-btn-inner {
      width: 56px; height: 56px;
      border-radius: 50%;
      background: var(--cream);
    }

    /* ---- Viewfinder ---- */
    .viewfinder-frame {
      position: relative;
    }
    .viewfinder-corner {
      position: absolute;
      width: 28px;
      height: 28px;
      border-color: var(--gold);
      border-style: solid;
    }
    .vc-tl { top: 0; left: 0; border-width: 3px 0 0 3px; }
    .vc-tr { top: 0; right: 0; border-width: 3px 3px 0 0; }
    .vc-bl { bottom: 0; left: 0; border-width: 0 0 3px 3px; }
    .vc-br { bottom: 0; right: 0; border-width: 0 3px 3px 0; }
    .viewfinder-guide {
      position: absolute;
      left: 0; right: 0;
      top: 50%;
      height: 2px;
      background: linear-gradient(90deg, transparent 10%, var(--emerald) 30%, var(--emerald) 70%, transparent 90%);
      box-shadow: 0 0 10px rgba(52,211,153,0.3);
    }

    /* ---- Video ---- */
    .video-container {
      position: relative;
      border-radius: 16px;
      overflow: hidden;
      background: var(--bg-primary);
      border: 1px solid var(--border);
    }
    .video-container video {
      width: 100%; height: 100%;
      object-fit: cover;
      display: block;
    }

    /* ---- Mute button ---- */
    .mute-btn {
      position: absolute;
      bottom: 12px; left: 12px;
      width: 36px; height: 36px;
      border-radius: 50%;
      border: 1px solid var(--border);
      background: rgba(11,26,14,0.7);
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      display: flex; align-items: center; justify-content: center;
      cursor: pointer;
      z-index: 10;
      color: var(--cream);
      font-size: 16px;
      transition: background 0.15s;
    }
    .mute-btn-active {
      background: rgba(239,68,68,0.3);
      border-color: rgba(239,68,68,0.4);
      color: var(--accent-red);
    }

    /* ---- PIP video ---- */
    .pip-video {
      position: absolute;
      top: 16px; right: 16px;
      width: 100px; height: 100px;
      border-radius: 16px;
      overflow: hidden;
      border: 1px solid var(--border);
      background: var(--bg-primary);
      z-index: 10;
    }
    .pip-video video { width: 100%; height: 100%; object-fit: cover; }

    /* ---- Toast ---- */
    .toast {
      position: fixed;
      top: 0; left: 0; right: 0;
      z-index: 50;
      display: flex; justify-content: center;
      padding: max(env(safe-area-inset-top), 16px) 24px 16px;
    }
    .toast-inner {
      background: rgba(19,42,24,0.85);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      color: var(--cream);
      padding: 14px 24px;
      border-radius: 14px;
      font-size: 14px;
      font-weight: 600;
      border: 1px solid var(--border);
      border-left: 3px solid var(--gold);
      max-width: 400px;
      width: 100%;
      text-align: center;
    }
    .toast-error .toast-inner {
      background: rgba(239,68,68,0.15);
      border-left-color: var(--accent-red);
      color: var(--accent-red);
    }

    /* ---- Timer pulse ---- */
    @keyframes timer-pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.04); }
    }
    .timer-pulse { animation: timer-pulse 0.5s ease-in-out infinite; }

    /* ---- Winner glow ---- */
    .winner-glow {
      box-shadow: 0 0 30px rgba(52, 211, 153, 0.4), 0 0 60px rgba(52, 211, 153, 0.2);
      border: 2px solid var(--emerald) !important;
    }

    /* ---- Instruction pill ---- */
    .instruction-pill {
      background: rgba(19,42,24,0.7);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      color: var(--gold);
      padding: 10px 20px;
      border-radius: 100px;
      font-size: 14px;
      font-weight: 600;
      border: 1px solid var(--border);
    }

    /* ---- Ready badge ---- */
    .ready-badge {
      padding: 6px 14px;
      border-radius: 100px;
      font-size: 12px;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.03em;
    }
    .ready-badge-on {
      background: var(--emerald);
      color: #fff;
      box-shadow: 0 0 12px rgba(52,211,153,0.4);
      animation: ready-glow 1.5s ease-in-out infinite;
    }
    .ready-badge-off {
      background: rgba(26,53,32,0.6);
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      color: var(--text-secondary);
      border: 1px solid var(--border);
    }
    @keyframes ready-glow {
      0%, 100% { box-shadow: 0 0 12px rgba(52,211,153,0.4); }
      50% { box-shadow: 0 0 20px rgba(52,211,153,0.6); }
    }

    /* ---- Pint float animation ---- */
    .pint-float {
      animation: pint-float 3s ease-in-out infinite;
    }
    @keyframes pint-float {
      0%, 100% {
        transform: translateY(0);
        filter: drop-shadow(0 0 15px rgba(212,168,67,0.3));
      }
      50% {
        transform: translateY(-8px);
        filter: drop-shadow(0 0 25px rgba(212,168,67,0.5));
      }
    }

    /* ---- Search ring spinner ---- */
    .search-ring {
      display: inline-block;
      animation: search-spin 1.5s linear infinite;
    }
    @keyframes search-spin {
      to { transform: rotate(360deg); }
    }

    /* ---- Animated gradient border ---- */
    @keyframes rotate-border {
      to { --border-angle: 360deg; }
    }
    .animated-gold-border {
      position: relative;
      border-radius: 16px;
      padding: 20px;
      background: rgba(26,53,32,0.8);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      border: none;
    }
    .animated-gold-border::before {
      content: '';
      position: absolute;
      inset: 0;
      border-radius: inherit;
      border: 2px solid transparent;
      background: conic-gradient(from var(--border-angle, 0deg), #D4A843, #34D399, #D4A843) border-box;
      -webkit-mask: linear-gradient(#fff 0 0) padding-box, linear-gradient(#fff 0 0);
      -webkit-mask-composite: xor;
      mask-composite: exclude;
      animation: rotate-border 3s linear infinite;
      pointer-events: none;
    }

    /* ---- Reduced motion ---- */
    @media (prefers-reduced-motion: reduce) {
      *, *::before, *::after {
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.01ms !important;
      }
      .pint-float { animation: none; }
      .search-ring { animation: none; }
      .pulsing-dots span { animation: none; opacity: 1; }
      .timer-pulse { animation: none; }
      .ready-badge-on { animation: none; }
      .ambient-particle { animation: none; display: none; }
      .confetti-particle { animation: none; display: none; }
      .scan-line { animation: none; }
    }

    /* ---- Ambient particles ---- */
    .ambient-particle {
      position: absolute;
      border-radius: 50%;
      background: rgba(212,168,67,0.3);
      bottom: -10px;
      animation: particle-drift linear infinite;
    }
    @keyframes particle-drift {
      0% { transform: translateY(0) translateX(0); opacity: 0; }
      10% { opacity: 0.5; }
      90% { opacity: 0.5; }
      100% { transform: translateY(-100vh) translateX(20px); opacity: 0; }
    }
  </style>
</head>
<body>
  <a href="#main-content" class="skip-link">Skip to main content</a>
  <div id="splash" role="status" aria-label="Loading application" style="position:fixed;inset:0;background:#0B1A0E;display:flex;align-items:center;justify-content:center;z-index:99999">
    <div style="text-align:center">
      <div style="font-family:'DM Sans',sans-serif;font-size:28px;font-weight:900;color:#F5E6C8;letter-spacing:0.04em">SPLIT IT</div>
      <div style="width:48px;height:3px;background:#34D399;border-radius:2px;margin:12px auto 0"></div>
      <div style="margin-top:20px;display:flex;gap:6px;justify-content:center">
        <span class="sp-dot" style="animation-delay:0s"></span>
        <span class="sp-dot" style="animation-delay:0.2s"></span>
        <span class="sp-dot" style="animation-delay:0.4s"></span>
      </div>
    </div>
  </div>
  <style>.sp-dot{width:8px;height:8px;border-radius:50%;background:#34D399;animation:sp 1.4s ease-in-out infinite}@keyframes sp{0%,80%,100%{opacity:.3;transform:scale(.8)}40%{opacity:1;transform:scale(1)}}</style>
  <main id="main-content" role="main">
    <div id="root"></div>
  </main>

  <!-- Noise texture overlay -->
  <svg style="position:fixed;inset:0;width:100%;height:100%;pointer-events:none;z-index:1;opacity:0.035">
    <filter id="noiseFilter">
      <feTurbulence type="fractalNoise" baseFrequency="0.8" numOctaves="4" stitchTiles="stitch"/>
    </filter>
    <rect width="100%" height="100%" filter="url(#noiseFilter)"/>
  </svg>

  <script type="text/babel">
    const { useState, useEffect, useRef, useCallback, useMemo, useReducer } = React;
    const { motion, AnimatePresence } = window.Motion;

    // ============ CONFIG ============
    const ICE_SERVERS = {
      iceServers: [
        { urls: 'stun:stun.l.google.com:19302' },
        { urls: 'stun:stun1.l.google.com:19302' }
      ]
    };

    const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
    const springConfig = prefersReducedMotion
      ? { type: "tween", duration: 0 }
      : { type: "spring", stiffness: 300, damping: 30 };

    // ============ UTILITIES ============

    // Haptic feedback
    function haptic(pattern = 50) {
      try { navigator.vibrate && navigator.vibrate(pattern); } catch (e) {}
    }

    // ============ SOUND SYSTEM ============
    // Global sound setting (persisted in localStorage)
    let _soundEnabled = localStorage.getItem('stg-sound') !== 'off';
    function setSoundEnabled(enabled) {
      _soundEnabled = enabled;
      localStorage.setItem('stg-sound', enabled ? 'on' : 'off');
    }
    function isSoundEnabled() { return _soundEnabled; }

    // Web Audio API — synthesized sound effects
    let _audioCtx = null;
    let _audioUnlocked = false;

    function getAudioCtx() {
      if (!_audioCtx) _audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      if (_audioCtx.state === 'suspended') _audioCtx.resume();
      return _audioCtx;
    }

    // iOS audio unlock — must be called on user interaction
    function unlockAudio() {
      if (_audioUnlocked) return;
      try {
        const ctx = getAudioCtx();
        // Create and play a silent buffer to unlock iOS audio
        const buffer = ctx.createBuffer(1, 1, 22050);
        const source = ctx.createBufferSource();
        source.buffer = buffer;
        source.connect(ctx.destination);
        source.start(0);
        _audioUnlocked = true;
      } catch (e) {}
    }

    // Unlock audio on first touch/click (iOS requirement)
    document.addEventListener('touchstart', unlockAudio, { once: true });
    document.addEventListener('click', unlockAudio, { once: true });

    function playTone(freq, duration, type = 'sine', vol = 0.15) {
      if (!_soundEnabled) return; // Respect sound toggle
      try {
        const ctx = getAudioCtx();
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, ctx.currentTime);
        gain.gain.setValueAtTime(vol, ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + duration);
        osc.connect(gain);
        gain.connect(ctx.destination);
        osc.start();
        osc.stop(ctx.currentTime + duration);
      } catch (e) {}
    }

    const sfx = {
      tick: () => playTone(800, 0.06),
      shutter: () => { playTone(1200, 0.05, 'square', 0.08); playTone(900, 0.08, 'sine', 0.06); },
      go: () => { playTone(523, 0.1); setTimeout(() => playTone(1047, 0.15), 100); },
      win: () => { playTone(784, 0.15); setTimeout(() => playTone(1047, 0.2), 150); },
      lose: () => playTone(300, 0.3, 'sine', 0.1),
      // New celebratory sound for personal best
      personalBest: () => {
        playTone(523, 0.1); // C
        setTimeout(() => playTone(659, 0.1), 100); // E
        setTimeout(() => playTone(784, 0.1), 200); // G
        setTimeout(() => playTone(1047, 0.25), 300); // High C
      },
    };

    // Compress image for network transmission
    function compressImage(dataUrl, maxWidth = 640, quality = 0.6) {
      return new Promise((resolve) => {
        const img = new Image();
        img.onload = () => {
          const scale = Math.min(1, maxWidth / img.width);
          const canvas = document.createElement('canvas');
          canvas.width = Math.round(img.width * scale);
          canvas.height = Math.round(img.height * scale);
          const ctx = canvas.getContext('2d');
          ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
          resolve(canvas.toDataURL('image/jpeg', quality));
        };
        img.onerror = () => resolve(dataUrl);
        img.src = dataUrl;
      });
    }

    // Accuracy → color
    function getAccuracyColor(acc) {
      if (acc >= 80) return '#34D399';
      if (acc >= 50) return '#D4A843';
      if (acc >= 25) return '#E8943A';
      return '#EF4444';
    }

    // Player rank based on games played and win rate
    function getPlayerRank(gamesPlayed, winRate) {
      if (gamesPlayed < 3) return { name: 'Rookie', color: '#7C9A82', icon: '\u2726' };
      if (gamesPlayed < 5) return winRate >= 60
        ? { name: 'Bronze', color: '#CD7F32', icon: '\u2726' }
        : { name: 'Rookie', color: '#7C9A82', icon: '\u2726' };
      if (gamesPlayed < 10) return winRate >= 65
        ? { name: 'Silver', color: '#C0C0C0', icon: '\u2727' }
        : winRate >= 40
          ? { name: 'Bronze', color: '#CD7F32', icon: '\u2726' }
          : { name: 'Rookie', color: '#7C9A82', icon: '\u2726' };
      if (gamesPlayed < 20) return winRate >= 70
        ? { name: 'Gold', color: '#D4A843', icon: '\u2605' }
        : winRate >= 50
          ? { name: 'Silver', color: '#C0C0C0', icon: '\u2727' }
          : { name: 'Bronze', color: '#CD7F32', icon: '\u2726' };
      if (winRate >= 75) return { name: 'Platinum', color: '#34D399', icon: '\u2605' };
      if (winRate >= 60) return { name: 'Gold', color: '#D4A843', icon: '\u2605' };
      if (winRate >= 45) return { name: 'Silver', color: '#C0C0C0', icon: '\u2727' };
      return { name: 'Bronze', color: '#CD7F32', icon: '\u2726' };
    }

    // ============ CUSTOM HOOKS ============

    function useSocket() {
      const [socket, setSocket] = useState(null);
      const [connected, setConnected] = useState(false);

      useEffect(() => {
        const s = io({
          transports: ['websocket', 'polling'],
          reconnectionDelay: 500,
          reconnectionDelayMax: 3000,
          reconnectionAttempts: 10,
          timeout: 10000
        });
        setSocket(s);
        s.on('connect', () => setConnected(true));
        s.on('disconnect', () => setConnected(false));
        s.on('connect_error', (err) => {
          console.warn('[Socket] connect_error:', err.message);
        });
        s.io.on('reconnect', (attempt) => {
          console.log('[Socket] reconnected after', attempt, 'attempts');
        });
        s.io.on('reconnect_failed', () => {
          console.warn('[Socket] reconnect_failed — all attempts exhausted');
        });
        return () => s.close();
      }, []);

      return { socket, connected };
    }

    function useStats() {
      const defaultStats = { gamesPlayed: 0, wins: 0, losses: 0, ties: 0, currentStreak: 0, bestStreak: 0, bestAccuracy: 0 };

      const [stats, setStats] = useState(() => {
        try {
          const saved = localStorage.getItem('stg-stats');
          if (saved) return { ...defaultStats, ...JSON.parse(saved) };
          // Migrate from old keys
          const migrated = { ...defaultStats };
          const oldStreak = parseInt(localStorage.getItem('stg-streak') || '0', 10);
          if (oldStreak > 0) { migrated.currentStreak = oldStreak; migrated.bestStreak = oldStreak; }
          const legacyHigh = parseInt(localStorage.getItem('split-g-highscore') || '0', 10);
          const legacyGames = parseInt(localStorage.getItem('split-g-games') || '0', 10);
          if (legacyHigh > 0) migrated.bestAccuracy = legacyHigh;
          if (legacyGames > 0) migrated.gamesPlayed = legacyGames;
          localStorage.removeItem('stg-streak');
          localStorage.removeItem('split-g-balance');
          localStorage.removeItem('split-g-highscore');
          localStorage.removeItem('split-g-games');
          if (migrated.gamesPlayed > 0 || migrated.currentStreak > 0) {
            localStorage.setItem('stg-stats', JSON.stringify(migrated));
          }
          return migrated;
        } catch (e) { return defaultStats; }
      });

      const persist = useCallback((s) => {
        try { localStorage.setItem('stg-stats', JSON.stringify(s)); } catch (e) {}
      }, []);

      const recordGame = useCallback(({ outcome, accuracy }) => {
        setStats(prev => {
          const next = { ...prev, gamesPlayed: prev.gamesPlayed + 1 };
          if (outcome === 'win') {
            next.wins = prev.wins + 1;
            next.currentStreak = prev.currentStreak + 1;
            if (next.currentStreak > prev.bestStreak) next.bestStreak = next.currentStreak;
          } else if (outcome === 'loss') {
            next.losses = prev.losses + 1;
            next.currentStreak = 0;
          } else {
            next.ties = prev.ties + 1;
          }
          if (accuracy > prev.bestAccuracy) next.bestAccuracy = accuracy;
          persist(next);
          return next;
        });
      }, [persist]);

      const winRate = useMemo(() => {
        if (stats.gamesPlayed === 0) return 0;
        return Math.round((stats.wins / stats.gamesPlayed) * 100);
      }, [stats.wins, stats.gamesPlayed]);

      return { stats, recordGame, winRate };
    }

    function useNickname() {
      const [nickname, setNickname] = useState(() => {
        try { return localStorage.getItem('stg-nickname') || ''; } catch { return ''; }
      });
      const save = useCallback((name) => {
        const trimmed = name.trim().slice(0, 16);
        setNickname(trimmed);
        try { localStorage.setItem('stg-nickname', trimmed); } catch {}
      }, []);
      return { nickname, setNickname: save };
    }

    function useLeaderboard() {
      const [entries, setEntries] = useState(() => {
        try {
          return JSON.parse(localStorage.getItem('stg-leaderboard') || '[]');
        } catch { return []; }
      });

      const addEntry = useCallback((nickname, accuracy, date) => {
        setEntries(prev => {
          const next = [...prev, { nickname: nickname || 'Anon', accuracy, date: date || Date.now() }]
            .sort((a, b) => b.accuracy - a.accuracy)
            .slice(0, 20);
          try { localStorage.setItem('stg-leaderboard', JSON.stringify(next)); } catch {}
          return next;
        });
      }, []);

      return { entries, addEntry };
    }

    const IS_MOBILE = /Mobi|Android/i.test(navigator.userAgent);

    function useWebRTC(socket, opponentId, isInitiator) {
      const pcRef = useRef(null);
      const localStreamRef = useRef(null);
      const [remoteStream, setRemoteStream] = useState(null);
      const [localStream, setLocalStream] = useState(null);
      const [connectionState, setConnectionState] = useState('new');
      const [error, setError] = useState(null); // null | 'camera' | 'connection'
      const [isMuted, setIsMuted] = useState(false);

      const toggleMute = useCallback(() => {
        if (localStreamRef.current) {
          localStreamRef.current.getAudioTracks().forEach(t => { t.enabled = !t.enabled; });
          setIsMuted(m => !m);
        }
      }, []);

      const cleanup = useCallback(() => {
        if (pcRef.current) { pcRef.current.close(); pcRef.current = null; }
        if (localStreamRef.current) {
          localStreamRef.current.getTracks().forEach(t => t.stop());
          localStreamRef.current = null;
        }
        setLocalStream(null);
        setRemoteStream(null);
        setConnectionState('new');
        setError(null);
        setIsMuted(false);
      }, []);

      // Cleanup on unmount
      useEffect(() => { return () => cleanup(); }, []);

      const start = useCallback(async () => {
        if (!socket || !opponentId) return;
        setError(null);
        try {
          // Fetch ICE config from server (includes TURN if configured)
          let iceConfig = ICE_SERVERS;
          try {
            iceConfig = await new Promise((resolve, reject) => {
              socket.emit('get-ice-config', (config) => {
                if (config && config.iceServers) resolve(config);
                else reject(new Error('No ICE config'));
              });
              setTimeout(() => reject(new Error('ICE config timeout')), 5000);
            });
          } catch (e) {
            // Fall back to hardcoded STUN servers
          }

          const stream = await navigator.mediaDevices.getUserMedia({
            video: {
              facingMode: 'user',
              width: { ideal: IS_MOBILE ? 320 : 640 },
              height: { ideal: IS_MOBILE ? 240 : 480 },
              frameRate: { ideal: IS_MOBILE ? 15 : 24 }
            },
            audio: true
          });
          localStreamRef.current = stream;
          setLocalStream(stream);

          const pc = new RTCPeerConnection(iceConfig);
          pcRef.current = pc;

          stream.getTracks().forEach(track => pc.addTrack(track, stream));

          // Limit video bitrate on mobile
          if (IS_MOBILE) {
            try {
              const videoSender = pc.getSenders().find(s => s.track && s.track.kind === 'video');
              if (videoSender) {
                const params = videoSender.getParameters();
                if (!params.encodings) params.encodings = [{}];
                params.encodings[0].maxBitrate = 250000;
                await videoSender.setParameters(params);
              }
            } catch (e) {}
          }

          pc.ontrack = (e) => {
            if (e.streams && e.streams[0]) {
              setRemoteStream(e.streams[0]);
            }
            if (e.track.kind === 'video') {
              setConnectionState('connected');
            }
          };
          pc.onicecandidate = (e) => {
            if (e.candidate) socket.emit('webrtc-ice-candidate', { candidate: e.candidate });
          };
          pc.onconnectionstatechange = () => {
            setConnectionState(pc.connectionState);
            if (pc.connectionState === 'failed') setError('connection');
          };

          if (isInitiator) {
            const offer = await pc.createOffer();
            await pc.setLocalDescription(offer);
            socket.emit('webrtc-offer', { offer });
          }
        } catch (err) {
          setConnectionState('failed');
          setError('camera');
        }
      }, [socket, opponentId, isInitiator]);

      const retry = useCallback(() => {
        cleanup();
        setTimeout(() => start(), 500);
      }, [cleanup, start]);

      useEffect(() => {
        if (!socket) return;
        const onOffer = async (data) => {
          const pc = pcRef.current;
          if (!pc) return;
          await pc.setRemoteDescription(new RTCSessionDescription(data.offer));
          const answer = await pc.createAnswer();
          await pc.setLocalDescription(answer);
          socket.emit('webrtc-answer', { answer });
        };
        const onAnswer = async (data) => {
          const pc = pcRef.current;
          if (!pc) return;
          await pc.setRemoteDescription(new RTCSessionDescription(data.answer));
        };
        const onIce = async (data) => {
          const pc = pcRef.current;
          if (!pc) return;
          if (!data.candidate) return;
          try {
            await pc.addIceCandidate(new RTCIceCandidate(data.candidate));
          } catch (e) {
            console.warn('[WebRTC] Failed to add ICE candidate:', e.message);
          }
        };
        socket.on('webrtc-offer', onOffer);
        socket.on('webrtc-answer', onAnswer);
        socket.on('webrtc-ice-candidate', onIce);
        return () => {
          socket.off('webrtc-offer', onOffer);
          socket.off('webrtc-answer', onAnswer);
          socket.off('webrtc-ice-candidate', onIce);
        };
      }, [socket]);

      return { localStream, remoteStream, connectionState, error, start, cleanup, retry, isMuted, toggleMute };
    }

    function useCamera(facingMode = 'environment') {
      const streamRef = useRef(null);
      const [stream, setStream] = useState(null);
      const [error, setError] = useState(false);

      const start = useCallback(async () => {
        setError(false);
        try {
          const s = await navigator.mediaDevices.getUserMedia({
            video: { facingMode, width: { ideal: 1920 }, height: { ideal: 1080 } }
          });
          streamRef.current = s;
          setStream(s);
          return s;
        } catch (err) {
          setError(true);
          return null;
        }
      }, [facingMode]);

      const stop = useCallback(() => {
        if (streamRef.current) {
          streamRef.current.getTracks().forEach(t => t.stop());
          streamRef.current = null;
        }
        setStream(null);
      }, []);

      const capture = useCallback((videoEl, canvas) => {
        if (!videoEl || !canvas) return null;
        const ctx = canvas.getContext('2d');
        canvas.width = videoEl.videoWidth || 640;
        canvas.height = videoEl.videoHeight || 480;
        ctx.drawImage(videoEl, 0, 0, canvas.width, canvas.height);
        return canvas.toDataURL('image/jpeg', 0.95);
      }, []);

      useEffect(() => { return () => { stop(); }; }, [stop]);

      return { stream, error, start, stop, capture };
    }

    function usePintAnalysis() {
      const [isAnalyzing, setIsAnalyzing] = useState(false);

      const analyze = useCallback((imageData, canvas) => {
        return new Promise((resolve) => {
          setIsAnalyzing(true);
          const ctx = canvas.getContext('2d');
          const img = new Image();
          img.src = imageData;
          img.onload = () => {
            canvas.width = img.width;
            canvas.height = img.height;
            ctx.drawImage(img, 0, 0);
            const { width, height } = canvas;
            let imageDataObj = ctx.getImageData(0, 0, width, height);
            let pixels = imageDataObj.data;

            // ========== PREPROCESSING: CONTRAST-LIMITED ADAPTIVE HISTOGRAM EQUALIZATION ==========
            // This dramatically improves detection in dark pub environments

            // Step 1: Build luminance histogram
            const histogram = new Array(256).fill(0);
            for (let i = 0; i < pixels.length; i += 4) {
              const lum = Math.round(0.299 * pixels[i] + 0.587 * pixels[i + 1] + 0.114 * pixels[i + 2]);
              histogram[lum]++;
            }

            // Step 2: Find actual min/max luminance (ignore outliers - bottom/top 1%)
            const totalPixels = (width * height);
            const clipThreshold = totalPixels * 0.01;
            let minLum = 0, maxLum = 255;
            let cumulative = 0;
            for (let i = 0; i < 256; i++) {
              cumulative += histogram[i];
              if (cumulative > clipThreshold) { minLum = i; break; }
            }
            cumulative = 0;
            for (let i = 255; i >= 0; i--) {
              cumulative += histogram[i];
              if (cumulative > clipThreshold) { maxLum = i; break; }
            }

            // Step 3: Apply contrast stretching if image is low contrast
            const contrast = maxLum - minLum;
            if (contrast < 100 && contrast > 10) {
              // Stretch the histogram to full 0-255 range
              const scale = 255 / contrast;
              for (let i = 0; i < pixels.length; i += 4) {
                const lum = 0.299 * pixels[i] + 0.587 * pixels[i + 1] + 0.114 * pixels[i + 2];
                const newLum = Math.min(255, Math.max(0, (lum - minLum) * scale));
                const factor = lum > 0 ? newLum / lum : 1;
                pixels[i] = Math.min(255, pixels[i] * factor);
                pixels[i + 1] = Math.min(255, pixels[i + 1] * factor);
                pixels[i + 2] = Math.min(255, pixels[i + 2] * factor);
              }
              // Update canvas with enhanced image
              ctx.putImageData(imageDataObj, 0, 0);
            }

            // ========== ROBUST PUB-FRIENDLY ANALYSIS ==========
            // Handles: low light, shadows, variable contrast, dark environments

            // 1. ADAPTIVE SAMPLING - scan more columns for better accuracy
            const numColumns = 15;
            const columnStart = 0.25;  // Start at 25% (avoid glass edges)
            const columnEnd = 0.75;    // End at 75%
            const columnSpacing = (columnEnd - columnStart) / (numColumns - 1);

            // 2. BUILD LUMINANCE PROFILE for the entire center region
            // This helps us understand the lighting conditions
            const columnProfiles = [];
            for (let c = 0; c < numColumns; c++) {
              const cx = Math.floor(width * (columnStart + c * columnSpacing));
              const profile = [];
              for (let y = 0; y < height; y++) {
                const i = (y * width + cx) * 4;
                const lum = 0.299 * pixels[i] + 0.587 * pixels[i + 1] + 0.114 * pixels[i + 2];
                profile.push(lum);
              }
              columnProfiles.push(profile);
            }

            // 3. COMPUTE IMAGE STATISTICS for adaptive thresholding
            // Sample the top 20% (likely foam/head area) and bottom 40% (likely stout)
            const topRegionEnd = Math.floor(height * 0.2);
            const bottomRegionStart = Math.floor(height * 0.6);
            let topLumSum = 0, topCount = 0;
            let bottomLumSum = 0, bottomCount = 0;

            for (const profile of columnProfiles) {
              for (let y = 0; y < topRegionEnd; y++) {
                topLumSum += profile[y];
                topCount++;
              }
              for (let y = bottomRegionStart; y < height; y++) {
                bottomLumSum += profile[y];
                bottomCount++;
              }
            }

            const avgTopLum = topCount > 0 ? topLumSum / topCount : 128;
            const avgBottomLum = bottomCount > 0 ? bottomLumSum / bottomCount : 64;

            // 4. ADAPTIVE THRESHOLD - adjusts to actual lighting conditions
            // Threshold is set between the dark (stout) and bright (foam) regions
            // Use weighted average biased towards brighter (foam detection)
            const lumRange = avgTopLum - avgBottomLum;
            const adaptiveThreshold = avgBottomLum + lumRange * 0.4;
            // Fallback: if contrast is too low, use a relative threshold
            const minContrast = 20;
            const threshold = lumRange > minContrast ? adaptiveThreshold : avgBottomLum + 15;

            // 5. GRADIENT-BASED EDGE DETECTION
            // Instead of just threshold, look for the steepest brightness change
            // This handles gradual lighting changes better
            const liquidYs = columnProfiles.map(profile => {
              let maxGradient = 0;
              let gradientY = height;
              let thresholdY = height;

              // Scan from bottom up
              for (let y = height - 5; y >= 5; y--) {
                // Compute local gradient (brightness change over 5 pixels)
                const gradientUp = profile[y - 5] - profile[y];

                // Track threshold crossing
                if (profile[y] > threshold && thresholdY === height) {
                  thresholdY = y;
                }

                // Track maximum gradient (foam/stout boundary)
                if (gradientUp > maxGradient && gradientUp > 10) {
                  maxGradient = gradientUp;
                  gradientY = y - 2; // Adjust to center of transition
                }
              }

              // Use gradient detection if strong edge found, otherwise threshold
              if (maxGradient > lumRange * 0.3 && lumRange > minContrast) {
                return gradientY;
              }
              return thresholdY;
            });

            // 6. ROBUST AGGREGATION - trimmed mean (remove outliers)
            // Sort and remove top/bottom 20% before averaging
            const sortedYs = [...liquidYs].sort((a, b) => a - b);
            const trimCount = Math.floor(numColumns * 0.2);
            const trimmedYs = sortedYs.slice(trimCount, sortedYs.length - trimCount);
            const liquidY = Math.round(trimmedYs.reduce((a, b) => a + b, 0) / trimmedYs.length);

            // 7. TARGET POSITION - the "G" line
            // Standard Guinness: G is approximately at 62% from top (38% from bottom)
            // We look for it in the upper-middle region of the visible glass
            const targetY = Math.floor(height * 0.52);

            // 8. ACCURACY CALCULATION with wider tolerance for real-world variance
            const distance = Math.abs(liquidY - targetY);
            const maxDistance = height * 0.18; // 18% tolerance (more forgiving)
            const accuracy = Math.max(0, Math.min(100, 100 - (distance / maxDistance) * 100));

            // 9. CONFIDENCE SCORE - how reliable is this reading?
            // Based on: contrast level, consistency of column readings, valid liquid position
            const columnVariance = trimmedYs.reduce((sum, y) => sum + Math.pow(y - liquidY, 2), 0) / trimmedYs.length;
            const columnStdDev = Math.sqrt(columnVariance);
            const consistencyScore = Math.max(0, 100 - columnStdDev * 2); // Penalize high variance
            const contrastScore = Math.min(100, lumRange * 2); // Higher contrast = more confident
            const positionScore = (liquidY > height * 0.2 && liquidY < height * 0.8) ? 100 : 50; // Valid range
            const confidence = Math.round((consistencyScore + contrastScore + positionScore) / 3);

            // 10. DEBUG INFO
            console.log('[PintAnalysis]', {
              preprocessing: { minLum, maxLum, contrast, enhanced: contrast < 100 && contrast > 10 },
              lighting: { avgTopLum: Math.round(avgTopLum), avgBottomLum: Math.round(avgBottomLum), lumRange: Math.round(lumRange) },
              detection: { threshold: Math.round(threshold), liquidY, targetY, columnStdDev: Math.round(columnStdDev) },
              result: { accuracy: Math.round(accuracy), confidence }
            });

            setIsAnalyzing(false);
            resolve({ liquidY, targetY, accuracy: Math.round(accuracy), height, confidence });
          };
          img.onerror = () => {
            setIsAnalyzing(false);
            resolve({ accuracy: 0, liquidY: 0, targetY: 0, height: 0 });
          };
        });
      }, []);

      return { analyze, isAnalyzing };
    }

    // ============ SHARED COMPONENTS ============

    function PulsingDots({ light }) {
      return (
        <div className={`pulsing-dots ${light ? 'pulsing-dots-light' : ''}`}>
          <span /><span /><span />
        </div>
      );
    }

    function SearchRing() {
      return (
        <div className="search-ring">
          <svg width="64" height="64" viewBox="0 0 64 64">
            <circle cx="32" cy="32" r="26" fill="none" stroke="rgba(52,211,153,0.15)" strokeWidth="3" />
            <circle cx="32" cy="32" r="26" fill="none" stroke="#34D399" strokeWidth="3"
              strokeDasharray="50 114" strokeLinecap="round" />
            <circle cx="32" cy="32" r="26" fill="none" stroke="#D4A843" strokeWidth="3"
              strokeDasharray="15 149" strokeLinecap="round" strokeDashoffset="-50" />
          </svg>
        </div>
      );
    }

    function TimerArc({ progress }) {
      const radius = 58;
      const circumference = 2 * Math.PI * radius;
      const offset = circumference * (1 - progress);
      const color = progress > 0.33 ? '#34D399' : progress > 0.17 ? '#D4A843' : '#EF4444';

      return (
        <svg width="200" height="200" viewBox="0 0 128 128"
          style={{ position: 'absolute', top: '50%', left: '50%', transform: 'translate(-50%, -50%) rotate(-90deg)' }}>
          <circle cx="64" cy="64" r={radius} fill="none" stroke="rgba(52,211,153,0.08)" strokeWidth="2" />
          <circle cx="64" cy="64" r={radius} fill="none"
            stroke={color}
            strokeWidth="2.5"
            strokeDasharray={circumference} strokeDashoffset={offset}
            strokeLinecap="round"
            style={{ transition: 'stroke-dashoffset 0.1s linear, stroke 1s ease' }} />
        </svg>
      );
    }

    function AmbientParticles() {
      return (
        <div style={{ position: 'absolute', inset: 0, overflow: 'hidden', pointerEvents: 'none' }}>
          {[0,1,2,3,4,5].map(i => (
            <div key={i} className="ambient-particle" style={{
              left: `${10 + i * 16}%`,
              width: 3 + (i % 3),
              height: 3 + (i % 3),
              animationDelay: `${i * 1.2}s`,
              animationDuration: `${6 + i * 1.5}s`,
            }} />
          ))}
        </div>
      );
    }

    function Toast({ message, type = 'info', visible }) {
      return (
        <AnimatePresence>
          {visible && (
            <motion.div
              initial={{ y: -60, opacity: 0 }}
              animate={{ y: 0, opacity: 1 }}
              exit={{ y: -60, opacity: 0 }}
              transition={springConfig}
              className={`toast ${type === 'error' ? 'toast-error' : ''}`}
            >
              <div className="toast-inner">{message}</div>
            </motion.div>
          )}
        </AnimatePresence>
      );
    }

    function ConnectionBanner({ connected }) {
      return (
        <AnimatePresence>
          {!connected && (
            <motion.div
              initial={{ y: -60, opacity: 0 }}
              animate={{ y: 0, opacity: 1 }}
              exit={{ y: -60, opacity: 0 }}
              transition={springConfig}
              style={{
                position: 'fixed',
                top: 0, left: 0, right: 0,
                zIndex: 45,
                display: 'flex', justifyContent: 'center',
                padding: 'max(env(safe-area-inset-top), 16px) 24px 12px',
              }}>
              <div style={{
                background: 'rgba(239,68,68,0.15)',
                backdropFilter: 'blur(20px)',
                WebkitBackdropFilter: 'blur(20px)',
                color: 'var(--accent-red)',
                padding: '12px 24px',
                borderRadius: 14,
                fontSize: 14,
                fontWeight: 600,
                border: '1px solid rgba(239,68,68,0.25)',
                maxWidth: 400,
                width: '100%',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                gap: 10,
              }}>
                Reconnecting...
                <PulsingDots />
              </div>
            </motion.div>
          )}
        </AnimatePresence>
      );
    }

    function VideoFeed({ stream, muted = false, mirrored = false, style, className = '' }) {
      const ref = useRef(null);
      useEffect(() => {
        if (ref.current && stream) ref.current.srcObject = stream;
      }, [stream]);
      return (
        <video
          ref={ref}
          autoPlay playsInline muted={muted}
          style={{ transform: mirrored ? 'scaleX(-1)' : 'none', ...style }}
          className={className}
        />
      );
    }

    function MuteButton({ isMuted, onToggle }) {
      return (
        <button className={`mute-btn ${isMuted ? 'mute-btn-active' : ''}`} onClick={() => { haptic(20); onToggle(); }} aria-label={isMuted ? 'Unmute' : 'Mute'}>
          {isMuted ? (
            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round">
              <line x1="1" y1="1" x2="23" y2="23"/><path d="M9 9v3a3 3 0 0 0 5.12 2.12M15 9.34V4a3 3 0 0 0-5.94-.6"/><path d="M17 16.95A7 7 0 0 1 5 12v-2m14 0v2c0 .76-.12 1.49-.34 2.18"/><line x1="12" y1="19" x2="12" y2="23"/><line x1="8" y1="23" x2="16" y2="23"/>
            </svg>
          ) : (
            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round">
              <path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/><line x1="12" y1="19" x2="12" y2="23"/><line x1="8" y1="23" x2="16" y2="23"/>
            </svg>
          )}
        </button>
      );
    }

    function ShutterButton({ onClick, disabled }) {
      return (
        <button className="shutter-btn" onClick={onClick} disabled={disabled}>
          <div className="shutter-btn-inner" />
        </button>
      );
    }

    // Result image with analysis overlay (shows detected liquid level vs target)
    function ResultImageWithOverlay({ src, liquidY, targetY, height, imgHeight = 120 }) {
      if (!src) return null;

      // Calculate overlay positions as percentages
      const liquidPercent = height > 0 ? (liquidY / height) * 100 : 50;
      const targetPercent = height > 0 ? (targetY / height) * 100 : 50;

      return (
        <div style={{ position: 'relative', marginBottom: 12 }}>
          <img src={src} alt="Result" style={{ width: '100%', height: imgHeight, objectFit: 'cover', borderRadius: 12 }} />
          {/* Overlay lines */}
          {height > 0 && (
            <div style={{ position: 'absolute', inset: 0, pointerEvents: 'none', borderRadius: 12, overflow: 'hidden' }}>
              {/* Target line (the G) - gold dashed */}
              <div style={{
                position: 'absolute',
                top: `${targetPercent}%`,
                left: 0, right: 0,
                height: 2,
                background: 'repeating-linear-gradient(90deg, var(--gold) 0px, var(--gold) 6px, transparent 6px, transparent 12px)',
                boxShadow: '0 0 4px rgba(212,168,67,0.6)',
                transform: 'translateY(-50%)'
              }} />
              {/* Detected liquid line - emerald solid */}
              <div style={{
                position: 'absolute',
                top: `${liquidPercent}%`,
                left: 0, right: 0,
                height: 3,
                background: 'var(--emerald)',
                boxShadow: '0 0 6px rgba(52,211,153,0.8)',
                transform: 'translateY(-50%)'
              }} />
              {/* Labels */}
              <div style={{
                position: 'absolute',
                top: `${targetPercent}%`,
                right: 6,
                transform: 'translateY(-50%)',
                fontSize: 9,
                fontWeight: 700,
                color: 'var(--gold)',
                background: 'rgba(0,0,0,0.7)',
                padding: '2px 5px',
                borderRadius: 4,
                letterSpacing: '0.05em'
              }}>TARGET</div>
              <div style={{
                position: 'absolute',
                top: `${liquidPercent}%`,
                left: 6,
                transform: 'translateY(-50%)',
                fontSize: 9,
                fontWeight: 700,
                color: 'var(--emerald)',
                background: 'rgba(0,0,0,0.7)',
                padding: '2px 5px',
                borderRadius: 4,
                letterSpacing: '0.05em'
              }}>YOURS</div>
            </div>
          )}
        </div>
      );
    }

    // Screen reader announcements (visually hidden, read by assistive tech)
    function ScreenReaderAnnounce({ message }) {
      return (
        <div
          role="status"
          aria-live="polite"
          aria-atomic="true"
          style={{
            position: 'absolute',
            width: 1, height: 1,
            padding: 0, margin: -1,
            overflow: 'hidden',
            clip: 'rect(0, 0, 0, 0)',
            whiteSpace: 'nowrap',
            border: 0
          }}>
          {message}
        </div>
      );
    }

    // Global sound toggle button (for landing page)
    function SoundToggle() {
      const [soundOn, setSoundOn] = useState(isSoundEnabled());
      const toggle = () => {
        const newState = !soundOn;
        setSoundOn(newState);
        setSoundEnabled(newState);
        haptic(20);
        if (newState) sfx.tick(); // Play a test sound when enabling
      };
      return (
        <button
          onClick={toggle}
          aria-label={soundOn ? 'Mute sounds' : 'Unmute sounds'}
          style={{
            position: 'absolute', top: 16, right: 16,
            width: 44, height: 44, borderRadius: '50%',
            background: 'var(--bg-elevated)', border: '1px solid var(--bg-surface)',
            display: 'flex', alignItems: 'center', justifyContent: 'center',
            color: soundOn ? 'var(--gold)' : 'var(--text-secondary)',
            cursor: 'pointer', transition: 'all 0.2s ease'
          }}>
          {soundOn ? (
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
              <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5" />
              <path d="M15.54 8.46a5 5 0 0 1 0 7.07" />
              <path d="M19.07 4.93a10 10 0 0 1 0 14.14" />
            </svg>
          ) : (
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
              <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5" />
              <line x1="23" y1="9" x2="17" y2="15" />
              <line x1="17" y1="9" x2="23" y2="15" />
            </svg>
          )}
        </button>
      );
    }

    function ConfettiBurst() {
      const particles = useMemo(() =>
        Array.from({ length: 20 }, (_, i) => ({
          id: i,
          left: 30 + Math.random() * 40,
          delay: Math.random() * 0.4,
          color: ['#34D399', '#D4A843', '#F5E6C8', '#34D399'][i % 4],
          rotation: Math.random() * 360,
        })), []);
      return (
        <div style={{ position: 'fixed', inset: 0, pointerEvents: 'none', zIndex: 100 }}>
          {particles.map(p => (
            <div key={p.id} className="confetti-particle" style={{
              left: `${p.left}%`, top: '-10px', background: p.color,
              animationDelay: `${p.delay}s`, transform: `rotate(${p.rotation}deg)`
            }} />
          ))}
        </div>
      );
    }

    function RollingNumber({ value, duration = 1000 }) {
      const [display, setDisplay] = useState(0);
      useEffect(() => {
        if (value === null || value === undefined) return;
        const startTime = performance.now();
        let rafId;
        const tick = (now) => {
          const elapsed = now - startTime;
          const progress = Math.min(elapsed / duration, 1);
          setDisplay(Math.floor(progress * value));
          if (progress < 1) {
            rafId = requestAnimationFrame(tick);
          } else {
            setDisplay(value);
          }
        };
        rafId = requestAnimationFrame(tick);
        return () => cancelAnimationFrame(rafId);
      }, [value, duration]);
      return <span style={{ fontFamily: "'Space Mono', monospace", fontVariantNumeric: 'tabular-nums' }}>{display}</span>;
    }

    function PintIcon() {
      return (
        <div className="pint-float">
          <svg width="120" height="170" viewBox="0 0 120 170" style={{ display: 'block', margin: '0 auto' }}>
            <defs>
              <linearGradient id="stoutGrad" x1="0" y1="0" x2="1" y2="1">
                <stop offset="0%" stopColor="#1A0800" />
                <stop offset="30%" stopColor="#2D0F00" />
                <stop offset="60%" stopColor="#1C0A00" />
                <stop offset="100%" stopColor="#0D0500" />
              </linearGradient>
              <linearGradient id="glassGrad" x1="0" y1="0" x2="1" y2="0">
                <stop offset="0%" stopColor="rgba(255,255,255,0.06)" />
                <stop offset="50%" stopColor="rgba(255,255,255,0.02)" />
                <stop offset="100%" stopColor="rgba(255,255,255,0.08)" />
              </linearGradient>
              <linearGradient id="foamGrad" x1="0" y1="0" x2="0" y2="1">
                <stop offset="0%" stopColor="#FFF8EC" />
                <stop offset="40%" stopColor="#F5E6C8" />
                <stop offset="100%" stopColor="#E8D5A8" />
              </linearGradient>
              <linearGradient id="highlightGrad" x1="0" y1="0" x2="0" y2="1">
                <stop offset="0%" stopColor="rgba(255,255,255,0.25)" />
                <stop offset="100%" stopColor="rgba(255,255,255,0)" />
              </linearGradient>
              <clipPath id="glassClip">
                <path d="M32 28 L27 140 Q27 152 38 152 L82 152 Q93 152 93 140 L88 28 Z" />
              </clipPath>
            </defs>

            {/* Glass outline */}
            <path d="M32 28 L27 140 Q27 152 38 152 L82 152 Q93 152 93 140 L88 28 Q88 22 80 22 L40 22 Q32 22 32 28 Z"
              fill="none" stroke="#D4A843" strokeWidth="1.5" strokeLinecap="round" opacity="0.7" />

            {/* Glass body */}
            <path d="M32 28 L27 140 Q27 152 38 152 L82 152 Q93 152 93 140 L88 28 Z"
              fill="url(#glassGrad)" />

            {/* Stout fill */}
            <g clipPath="url(#glassClip)">
              <rect x="25" y="62" width="70" height="95" fill="url(#stoutGrad)" />
              <rect x="25" y="62" width="70" height="8" fill="#2A1200" opacity="0.5" />
              <line x1="42" y1="70" x2="43" y2="145" stroke="rgba(60,25,0,0.3)" strokeWidth="0.5" />
              <line x1="55" y1="68" x2="56" y2="148" stroke="rgba(60,25,0,0.2)" strokeWidth="0.5" />
              <line x1="70" y1="72" x2="69" y2="146" stroke="rgba(60,25,0,0.3)" strokeWidth="0.5" />
              <line x1="78" y1="69" x2="77" y2="144" stroke="rgba(60,25,0,0.2)" strokeWidth="0.5" />
            </g>

            {/* Foam head */}
            <ellipse cx="60" cy="62" rx="30" ry="12" fill="url(#foamGrad)" />
            <ellipse cx="60" cy="60" rx="28" ry="9" fill="#FFF8EC" opacity="0.6" />
            <ellipse cx="55" cy="58" rx="18" ry="5" fill="#FFFDF5" opacity="0.3" />

            {/* Foam bubbles */}
            <circle cx="48" cy="60" r="2" fill="#FFFDF5" opacity="0.4" />
            <circle cx="65" cy="59" r="1.5" fill="#FFFDF5" opacity="0.35" />
            <circle cx="72" cy="62" r="1.8" fill="#FFFDF5" opacity="0.3" />
            <circle cx="52" cy="57" r="1" fill="#FFFDF5" opacity="0.5" />

            {/* Glass rim */}
            <ellipse cx="60" cy="24" rx="25" ry="5" stroke="#D4A843" strokeWidth="1" fill="none" opacity="0.5" />

            {/* Glass reflections */}
            <path d="M35 30 L31 130 Q34 30 35 30 Z" fill="url(#highlightGrad)" opacity="0.4" />
            <path d="M86 35 L84 90 Q87 35 86 35 Z" fill="rgba(255,255,255,0.12)" />

            {/* Condensation */}
            <circle cx="38" cy="95" r="1.2" fill="rgba(255,255,255,0.15)" />
            <circle cx="82" cy="105" r="1" fill="rgba(255,255,255,0.12)" />
            <circle cx="36" cy="115" r="0.8" fill="rgba(255,255,255,0.1)" />
            <circle cx="84" cy="85" r="1.1" fill="rgba(255,255,255,0.13)" />
            <circle cx="40" cy="130" r="0.9" fill="rgba(255,255,255,0.11)" />

            {/* Base shadow */}
            <ellipse cx="60" cy="155" rx="22" ry="3" fill="rgba(0,0,0,0.2)" />
          </svg>
        </div>
      );
    }

    function StatCard({ label, value, color }) {
      return (
        <div className="card-dark" style={{ padding: 12, textAlign: 'center' }}>
          <p className="t-label" style={{ marginBottom: 4, fontSize: 10 }}>{label}</p>
          <div style={{ fontSize: 22, fontWeight: 700, fontFamily: "'Space Mono', monospace", fontVariantNumeric: 'tabular-nums', color: color || 'var(--cream)' }}>
            {value}
          </div>
        </div>
      );
    }

    function LeaderboardCard({ entries }) {
      if (!entries.length) return null;
      const medals = ['\uD83E\uDD47', '\uD83E\uDD48', '\uD83E\uDD49'];
      return (
        <div className="card-dark" style={{ marginTop: 16, padding: 16 }}>
          <p className="t-label" style={{ marginBottom: 12, textAlign: 'center' }}>BEST SPLITS</p>
          {entries.slice(0, 5).map((e, i) => (
            <div key={i} style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', padding: '6px 0', borderBottom: i < Math.min(entries.length, 5) - 1 ? '1px solid var(--border)' : 'none' }}>
              <span style={{ fontSize: 14, color: 'var(--cream)', fontWeight: 600 }}>
                {i < 3 ? medals[i] : `${i + 1}.`} {e.nickname}
              </span>
              <span style={{ fontSize: 14, fontWeight: 700, fontFamily: "'Space Mono', monospace", color: getAccuracyColor(e.accuracy) }}>
                {e.accuracy}%
              </span>
            </div>
          ))}
        </div>
      );
    }

    function SeriesScoreBar({ myScore, opScore, round, opponentName }) {
      return (
        <div style={{ display: 'flex', justifyContent: 'center', alignItems: 'center', gap: 16, padding: '8px 0' }}>
          <div style={{ textAlign: 'center' }}>
            <div style={{ fontSize: 11, color: 'var(--text-secondary)' }}>YOU</div>
            <div style={{ fontSize: 24, fontWeight: 700, fontFamily: "'Space Mono', monospace", color: 'var(--emerald)' }}>{myScore}</div>
          </div>
          <div style={{ fontSize: 12, color: 'var(--gold)', fontWeight: 700 }}>ROUND {round}</div>
          <div style={{ textAlign: 'center' }}>
            <div style={{ fontSize: 11, color: 'var(--text-secondary)' }}>{opponentName || 'OPP'}</div>
            <div style={{ fontSize: 24, fontWeight: 700, fontFamily: "'Space Mono', monospace", color: 'var(--accent-red)' }}>{opScore}</div>
          </div>
        </div>
      );
    }

    function LandscapeWarning() {
      const [isLandscape, setIsLandscape] = useState(false);
      useEffect(() => {
        const check = () => setIsLandscape(window.innerHeight < 500 && window.innerWidth > window.innerHeight);
        check();
        window.addEventListener('resize', check);
        window.addEventListener('orientationchange', check);
        return () => { window.removeEventListener('resize', check); window.removeEventListener('orientationchange', check); };
      }, []);
      if (!isLandscape) return null;
      return (
        <div style={{ position: 'fixed', inset: 0, zIndex: 9999, background: 'var(--bg-primary)', display: 'flex', alignItems: 'center', justifyContent: 'center', flexDirection: 'column', gap: 16 }}>
          <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="var(--gold)" strokeWidth="1.5" strokeLinecap="round" strokeLinejoin="round">
            <rect x="4" y="2" width="16" height="20" rx="2"/>
            <path d="M12 18h.01"/>
          </svg>
          <p style={{ color: 'var(--cream)', fontSize: 18, fontWeight: 700 }}>Please rotate your device</p>
          <p style={{ color: 'var(--text-secondary)', fontSize: 14 }}>SPLIT IT works best in portrait mode</p>
        </div>
      );
    }

    // ============ SCREEN COMPONENTS ============

    function LandingScreen({ onStart, onQuickPlay, stats, winRate, nickname, onSetNickname, leaderboardEntries, seriesMode, onSetSeriesMode }) {
      const rank = getPlayerRank(stats.gamesPlayed, winRate);
      const hasPlayed = stats.gamesPlayed > 0;

      return (
        <motion.div
          key="landing"
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
          exit={{ opacity: 0, y: -20 }}
          transition={springConfig}
          style={{ minHeight: '100vh', background: 'var(--bg-primary)', display: 'flex', flexDirection: 'column', position: 'relative', overflow: 'hidden' }}
          className="safe-top safe-bottom"
        >
          <SoundToggle />
          <AmbientParticles />
          <div className="layout" style={{ flex: 1, display: 'flex', flexDirection: 'column', justifyContent: 'center', alignItems: 'center', gap: 12, position: 'relative', zIndex: 1 }}>
            <div style={{ textAlign: 'center', marginBottom: 16 }}>
              <div className="pint-float">
                <img src="guinness-cheers.png" alt="Guinness Cheers" style={{
                  width: 200, height: 'auto', display: 'block', margin: '0 auto'
                }} />
              </div>
            </div>
            <h1 style={{ fontSize: 32, fontWeight: 900, letterSpacing: '0.08em', color: 'var(--cream)', textAlign: 'center' }}>
              SPLIT <span style={{ fontSize: 44, color: 'var(--gold)', fontWeight: 900 }}>I</span>T
            </h1>
            <div style={{ width: 48, height: 3, background: 'var(--emerald)', borderRadius: 2, margin: '4px auto 0' }} />
            <p style={{ textAlign: 'center', color: 'var(--gold)', fontSize: 15, fontWeight: 500, letterSpacing: '0.06em', marginTop: 8, fontStyle: 'italic' }}>Sláinte</p>

            {hasPlayed && (
              <div style={{
                display: 'inline-flex', alignItems: 'center', gap: 6,
                padding: '6px 16px', borderRadius: 100,
                background: rank.color + '15',
                border: '1px solid ' + rank.color + '33',
                color: rank.color, fontSize: 13, fontWeight: 700,
                fontFamily: "'Space Mono', monospace", marginTop: 8
              }}>
                {rank.icon} {rank.name}
              </div>
            )}

            {hasPlayed && (
              <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: 10, width: '100%', marginTop: 16 }}>
                <StatCard label="PLAYED" value={stats.gamesPlayed} />
                <StatCard label="WIN RATE" value={winRate + '%'} color={winRate >= 50 ? 'var(--emerald)' : 'var(--text-secondary)'} />
                <StatCard label="STREAK" value={stats.currentStreak} color={stats.currentStreak > 0 ? 'var(--emerald)' : 'var(--text-secondary)'} />
                <StatCard label="BEST ACC" value={stats.bestAccuracy + '%'} color={getAccuracyColor(stats.bestAccuracy)} />
              </div>
            )}

            {hasPlayed && (
              <div style={{ display: 'flex', justifyContent: 'center', gap: 16, fontSize: 12, color: 'var(--text-secondary)', marginTop: 8 }}>
                <span>Best Streak: {stats.bestStreak}</span>
                <span>{stats.wins}W - {stats.losses}L - {stats.ties}T</span>
              </div>
            )}

            <div className="card-dark" style={{ padding: '12px 16px', display: 'flex', alignItems: 'center', gap: 10, width: '100%', marginTop: 16 }}>
              <span style={{ fontSize: 12, fontWeight: 700, color: 'var(--gold)', whiteSpace: 'nowrap' }}>NAME</span>
              <input
                type="text"
                value={nickname}
                onChange={(e) => onSetNickname(e.target.value)}
                placeholder="Enter nickname"
                maxLength={16}
                style={{
                  flex: 1, background: 'transparent', border: 'none', outline: 'none',
                  color: 'var(--cream)', fontSize: 16, fontWeight: 600,
                  fontFamily: "'DM Sans', sans-serif"
                }}
              />
            </div>

            {leaderboardEntries && leaderboardEntries.length > 0 && (
              <LeaderboardCard entries={leaderboardEntries} />
            )}

            <div style={{ height: hasPlayed ? 16 : 32 }} />
            <button className="btn-primary" onClick={() => { haptic(30); onStart(); }}>Get Started</button>
          </div>
        </motion.div>
      );
    }

    function CaptureScreen({ mode, onCapture, onCancel, capturedImage, isScanning, analysisResult, remoteStream }) {
      const videoRef = useRef(null);
      const camera = useCamera('environment');
      const [ready, setReady] = useState(false);
      const [showFlash, setShowFlash] = useState(false);

      useEffect(() => {
        camera.start();
        return () => camera.stop();
      }, []);

      useEffect(() => {
        if (videoRef.current && camera.stream) {
          videoRef.current.srcObject = camera.stream;
          videoRef.current.onloadedmetadata = () => setReady(true);
        }
      }, [camera.stream]);

      const instruction = mode === 'full-pint' ? 'Photograph your full pint' : 'Show your result';

      const handleShutter = useCallback(() => {
        setShowFlash(true);
        haptic(40);
        sfx.shutter();
        setTimeout(() => setShowFlash(false), 150);
        const canvas = document.createElement('canvas');
        const img = camera.capture(videoRef.current, canvas);
        if (img) onCapture(img);
      }, [camera, onCapture]);

      if (capturedImage) {
        return (
          <motion.div key="capture-result-view" initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0 }}
            transition={springConfig}
            style={{ minHeight: '100vh', background: '#000', position: 'relative' }}>
            <img src={capturedImage} alt="Captured" style={{ width: '100%', height: '100vh', objectFit: 'cover' }} />
            {isScanning && <div className="scan-line" />}
            <div style={{ position: 'absolute', top: 0, left: 0, right: 0 }} className="safe-top">
              <div style={{ display: 'flex', justifyContent: 'center', padding: 16 }}>
                <div className="instruction-pill">Analyzing...</div>
              </div>
            </div>
          </motion.div>
        );
      }

      return (
        <motion.div
          key="capture"
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          exit={{ opacity: 0 }}
          transition={springConfig}
          style={{ minHeight: '100vh', background: '#000', position: 'relative' }}
        >
          {/* Camera flash overlay */}
          {showFlash && <div style={{ position: 'absolute', inset: 0, background: 'rgba(255,255,255,0.75)', zIndex: 20, pointerEvents: 'none' }} />}

          {camera.error ? (
            <div style={{ position: 'absolute', inset: 0, display: 'flex', alignItems: 'center', justifyContent: 'center', background: 'var(--bg-primary)', color: 'var(--cream)', padding: 24, textAlign: 'center' }}>
              <div style={{ display: 'flex', flexDirection: 'column', alignItems: 'center', gap: 16, maxWidth: 300 }}>
                <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="var(--accent-red)" strokeWidth="1.5" strokeLinecap="round" strokeLinejoin="round">
                  <path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"/>
                  <circle cx="12" cy="13" r="4"/>
                  <line x1="2" y1="2" x2="22" y2="22"/>
                </svg>
                <p className="t-title" style={{ color: 'var(--cream)', marginBottom: 4 }}>Camera Access Required</p>
                <p className="t-small" style={{ lineHeight: 1.5 }}>
                  SPLIT IT needs your camera to photograph your pint.
                  Please allow camera access in your browser settings.
                </p>
                <div style={{ fontSize: 12, color: 'var(--text-secondary)', background: 'var(--bg-elevated)', padding: '10px 14px', borderRadius: 10, lineHeight: 1.6, textAlign: 'left', width: '100%' }}>
                  <strong style={{ color: 'var(--cream)' }}>iOS:</strong> Settings &gt; Safari &gt; Camera &gt; Allow<br/>
                  <strong style={{ color: 'var(--cream)' }}>Android:</strong> Tap the lock icon in the address bar
                </div>
                <button className="btn-primary" style={{ width: 200 }} onClick={() => { haptic(20); camera.start(); }}>Try Again</button>
                {onCancel && <button className="btn-text" style={{ color: 'var(--text-secondary)' }} onClick={() => { haptic(20); onCancel(); }}>Go Back</button>}
              </div>
            </div>
          ) : (
            <>
              <video ref={videoRef} autoPlay playsInline muted style={{ position: 'absolute', inset: 0, width: '100%', height: '100%', objectFit: 'cover' }} />

              {/* Opponent PIP during result capture */}
              {remoteStream && (
                <div className="pip-video" style={{ top: 80 }}>
                  <VideoFeed stream={remoteStream} mirrored />
                </div>
              )}

              {/* Instruction pill */}
              <div style={{ position: 'absolute', top: 0, left: 0, right: 0, zIndex: 5 }} className="safe-top">
                <div style={{ display: 'flex', justifyContent: 'center', padding: 16 }}>
                  <div className="instruction-pill">{instruction}</div>
                </div>
              </div>

              {/* Viewfinder with gold corner brackets */}
              <div style={{ position: 'absolute', inset: 0, display: 'flex', alignItems: 'center', justifyContent: 'center', padding: 48 }}>
                <div className="viewfinder-frame" style={{ width: '100%', maxWidth: 280, aspectRatio: '3/4' }}>
                  <div className="viewfinder-corner vc-tl" />
                  <div className="viewfinder-corner vc-tr" />
                  <div className="viewfinder-corner vc-bl" />
                  <div className="viewfinder-corner vc-br" />
                  <div className="viewfinder-guide" />
                </div>
              </div>

              {/* Bottom controls */}
              <div style={{ position: 'absolute', bottom: 0, left: 0, right: 0, zIndex: 5 }} className="safe-bottom">
                <div style={{ display: 'flex', flexDirection: 'column', alignItems: 'center', gap: 16, padding: '0 24px 16px' }}>
                  <ShutterButton onClick={handleShutter} disabled={!ready} />
                  {onCancel && <button className="btn-text" style={{ color: 'var(--text-secondary)' }} onClick={() => { haptic(20); onCancel(); }}>Cancel</button>}
                </div>
              </div>
            </>
          )}
        </motion.div>
      );
    }

    function SearchingScreen({ onCancel, onSolo }) {
      const [countdown, setCountdown] = useState(30);
      const [timedOut, setTimedOut] = useState(false);

      // Pre-request camera permission so it's ready for capture-result
      useEffect(() => {
        let stream = null;
        navigator.mediaDevices.getUserMedia({
          video: { facingMode: 'environment', width: { ideal: 1920 }, height: { ideal: 1080 } }
        }).then(s => {
          stream = s;
          s.getTracks().forEach(t => t.stop());
        }).catch(() => {});
        return () => {
          if (stream) stream.getTracks().forEach(t => t.stop());
        };
      }, []);

      useEffect(() => {
        const interval = setInterval(() => {
          setCountdown(c => {
            if (c <= 1) {
              clearInterval(interval);
              setTimedOut(true);
              return 0;
            }
            return c - 1;
          });
        }, 1000);
        return () => clearInterval(interval);
      }, []);

      // Auto-trigger solo mode on timeout
      useEffect(() => {
        if (timedOut) onSolo();
      }, [timedOut, onSolo]);

      return (
        <motion.div
          key="searching"
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          exit={{ opacity: 0 }}
          transition={springConfig}
          style={{ minHeight: '100vh', background: 'var(--bg-primary)', display: 'flex', flexDirection: 'column', alignItems: 'center', justifyContent: 'center' }}
        >
          <div className="layout" style={{ textAlign: 'center' }}>
            <div style={{ marginBottom: 24 }}>
              <SearchRing />
            </div>
            <p style={{ fontSize: 20, fontWeight: 600, color: 'var(--gold)', marginBottom: 8 }}>Looking for an opponent</p>
            <p className="t-small" style={{ marginBottom: 8 }}>
              {countdown > 0 ? 'This won\'t take long' : 'Starting solo mode...'}
            </p>
            <p style={{ fontSize: 13, fontWeight: 600, fontFamily: "'Space Mono', monospace", color: 'var(--text-secondary)', marginBottom: 24 }}>
              {countdown > 0 && `Solo mode in ${countdown}s`}
            </p>
            <div style={{ display: 'flex', flexDirection: 'column', gap: 12, alignItems: 'center' }}>
              <button className="btn-text" style={{ color: 'var(--emerald)' }} onClick={() => { haptic(30); onSolo(); }}>Play Solo Now</button>
              <button className="btn-text" onClick={() => { haptic(20); onCancel(); }}>Cancel</button>
            </div>
          </div>
        </motion.div>
      );
    }

    function MatchedScreen({ localStream, remoteStream, onReady, connectionState, webrtcError, onRetryWebRTC, isMuted, onToggleMute, opponentPintImage }) {
      const [toastVisible, setToastVisible] = useState(true);
      const [timedOut, setTimedOut] = useState(false);
      const [autoRetries, setAutoRetries] = useState(0);

      useEffect(() => {
        const t = setTimeout(() => setToastVisible(false), 3000);
        return () => clearTimeout(t);
      }, []);

      // 15s timeout for remote stream
      useEffect(() => {
        if (remoteStream) { setTimedOut(false); return; }
        const t = setTimeout(() => setTimedOut(true), 15000);
        return () => clearTimeout(t);
      }, [remoteStream]);

      const hasFailed = webrtcError || connectionState === 'failed' || timedOut;
      const errorMessage = webrtcError === 'camera'
        ? 'Camera access was denied. Please allow camera permissions.'
        : webrtcError === 'connection'
          ? 'Video connection failed.'
          : timedOut
            ? 'Connection timed out.'
            : null;

      // Auto-retry up to 3 times
      useEffect(() => {
        if (hasFailed && autoRetries < 3 && webrtcError !== 'camera') {
          const t = setTimeout(() => {
            setAutoRetries(c => c + 1);
            setTimedOut(false);
            onRetryWebRTC();
          }, 2000 + autoRetries * 1000);
          return () => clearTimeout(t);
        }
      }, [hasFailed, autoRetries, webrtcError]);

      const connectionPhase = useMemo(() => {
        if (webrtcError === 'camera') return 'camera-error';
        if (hasFailed && autoRetries >= 3) return 'failed';
        if (hasFailed && autoRetries < 3) return 'retrying';
        if (remoteStream) return 'connected';
        if (connectionState === 'connecting') return 'connecting';
        return 'starting';
      }, [webrtcError, hasFailed, autoRetries, remoteStream, connectionState]);

      const statusMessage = {
        'starting': 'Initializing connection...',
        'connecting': 'Establishing peer connection...',
        'retrying': `Retrying... (${autoRetries + 1}/3)`,
        'connected': null,
        'camera-error': errorMessage,
        'failed': errorMessage,
      }[connectionPhase];

      return (
        <motion.div
          key="matched"
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          exit={{ opacity: 0 }}
          transition={springConfig}
          style={{ minHeight: '100vh', background: 'var(--bg-primary)', display: 'flex', flexDirection: 'column' }}
          className="safe-top safe-bottom"
        >
          <Toast message="Matched! Connecting video..." visible={toastVisible} />
          <div style={{ flex: 1, display: 'grid', gridTemplateRows: '1fr 1fr', gap: 8, padding: '8px 8px 0' }}>
            <div className="video-container" style={{ position: 'relative' }}>
              {remoteStream ? <VideoFeed stream={remoteStream} mirrored /> : (
                <div style={{ width: '100%', height: '100%', display: 'flex', flexDirection: 'column', alignItems: 'center', justifyContent: 'center', color: 'var(--text-secondary)', minHeight: 200, gap: 12, padding: 24, textAlign: 'center' }}>
                  {connectionPhase === 'failed' || connectionPhase === 'camera-error' ? (
                    <>
                      <p style={{ color: 'var(--accent-red)', fontSize: 14, fontWeight: 600 }}>{statusMessage}</p>
                      <button className="btn-text" style={{ color: 'var(--emerald)' }} onClick={() => { haptic(20); setAutoRetries(0); setTimedOut(false); onRetryWebRTC(); }}>Retry Connection</button>
                      {connectionPhase === 'failed' && (
                        <button className="btn-text" style={{ color: 'var(--text-secondary)', fontSize: 12 }} onClick={() => { haptic(20); onReady(); }}>Continue Without Video</button>
                      )}
                    </>
                  ) : (
                    <>
                      <PulsingDots light />
                      <p style={{ fontSize: 13, color: 'var(--text-secondary)' }}>{statusMessage}</p>
                    </>
                  )}
                </div>
              )}
              {opponentPintImage && (
                <img src={opponentPintImage} alt="Opponent's pint"
                  style={{ position: 'absolute', bottom: 8, right: 8, width: 48, height: 64, objectFit: 'cover', borderRadius: 8, border: '2px solid rgba(255,255,255,0.2)', boxShadow: '0 2px 8px rgba(0,0,0,0.4)' }} />
              )}
            </div>
            <div className="video-container" style={{ position: 'relative' }}>
              {localStream ? <VideoFeed stream={localStream} muted mirrored /> : (
                <div style={{ width: '100%', height: '100%', display: 'flex', flexDirection: 'column', alignItems: 'center', justifyContent: 'center', color: 'var(--text-secondary)', minHeight: 200, gap: 12 }}>
                  <PulsingDots light />
                  <p style={{ fontSize: 13, color: 'var(--text-secondary)' }}>Starting camera...</p>
                </div>
              )}
              {localStream && <MuteButton isMuted={isMuted} onToggle={onToggleMute} />}
            </div>
          </div>
          <div style={{ padding: '16px 24px' }}>
            <button className="btn-primary-light" onClick={() => { haptic(30); onReady(); }} disabled={!localStream}>
              {localStream ? 'Continue' : 'Starting camera...'}
            </button>
          </div>
        </motion.div>
      );
    }

    function ReadyScreen({ localStream, remoteStream, myReady, opponentReady, onReady, isMuted, onToggleMute }) {
      return (
        <motion.div
          key="ready"
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          exit={{ opacity: 0 }}
          transition={springConfig}
          style={{ minHeight: '100vh', background: 'var(--bg-primary)', display: 'flex', flexDirection: 'column' }}
          className="safe-top safe-bottom"
        >
          <div style={{ flex: 1, display: 'grid', gridTemplateRows: '1fr 1fr', gap: 8, padding: '8px 8px 0' }}>
            <div className="video-container" style={{ position: 'relative' }}>
              {remoteStream ? <VideoFeed stream={remoteStream} mirrored /> : (
                <div style={{ width: '100%', height: '100%', display: 'flex', alignItems: 'center', justifyContent: 'center', minHeight: 200 }}>
                  <PulsingDots light />
                </div>
              )}
              <div style={{ position: 'absolute', top: 12, right: 12 }}>
                <div className={`ready-badge ${opponentReady ? 'ready-badge-on' : 'ready-badge-off'}`}>
                  {opponentReady ? 'READY' : '...'}
                </div>
              </div>
            </div>
            <div className="video-container" style={{ position: 'relative' }}>
              {localStream ? <VideoFeed stream={localStream} muted mirrored /> : (
                <div style={{ width: '100%', height: '100%', display: 'flex', alignItems: 'center', justifyContent: 'center', minHeight: 200 }}>
                  <PulsingDots light />
                </div>
              )}
              <div style={{ position: 'absolute', top: 12, right: 12 }}>
                <div className={`ready-badge ${myReady ? 'ready-badge-on' : 'ready-badge-off'}`}>
                  {myReady ? 'READY' : '...'}
                </div>
              </div>
              {localStream && <MuteButton isMuted={isMuted} onToggle={onToggleMute} />}
            </div>
          </div>
          <div style={{ padding: '16px 24px' }}>
            {!myReady ? (
              <button className="btn-success" onClick={() => { haptic(30); onReady(); }}>Ready Up</button>
            ) : (
              <button className="btn-primary-light" disabled>Waiting for opponent...</button>
            )}
          </div>
        </motion.div>
      );
    }

    function CountdownScreen({ gameStartTime, remoteStream, onDone, soloMode, soloFallback, isMuted, onToggleMute }) {
      const [phase, setPhase] = useState('pre'); // 'pre' | 'timer'
      const [preNum, setPreNum] = useState(3);
      const [timer, setTimer] = useState(20);
      const [showGo, setShowGo] = useState(false);
      const [flash, setFlash] = useState(false);
      const rafRef = useRef(null);
      const timerStartRef = useRef(null);

      const goPhrase = useMemo(() => ['Slainte!', 'GO!', 'Slainte!', 'GO!'][Math.floor(Math.random() * 4)], []);

      // Haptic + sound on countdown number change
      useEffect(() => {
        if (phase === 'pre' && !showGo) {
          sfx.tick();
          haptic(30);
        }
      }, [preNum]);

      useEffect(() => {
        // Pre-countdown: 3, 2, 1, GO!
        const delay = gameStartTime ? Math.max(0, gameStartTime - Date.now()) : 0;

        const t3 = setTimeout(() => setPreNum(3), 0);
        const t2 = setTimeout(() => setPreNum(2), delay > 2000 ? delay / 3 : 1000);
        const t1 = setTimeout(() => setPreNum(1), delay > 2000 ? (delay / 3) * 2 : 2000);
        const tGo = setTimeout(() => {
          setShowGo(true);
          setFlash(true);
          sfx.go();
          haptic([50, 30, 100]);
          setTimeout(() => setFlash(false), 200);
        }, delay > 2000 ? delay - 200 : 2800);

        const tStart = setTimeout(() => {
          setPhase('timer');
          timerStartRef.current = performance.now();
          const tick = (now) => {
            const elapsed = (now - timerStartRef.current) / 1000;
            const remaining = Math.max(0, +(20 - elapsed).toFixed(1));
            setTimer(remaining);
            if (remaining > 0) {
              rafRef.current = requestAnimationFrame(tick);
            }
          };
          rafRef.current = requestAnimationFrame(tick);
        }, Math.max(delay, 3000));

        return () => {
          clearTimeout(t3); clearTimeout(t2); clearTimeout(t1); clearTimeout(tGo); clearTimeout(tStart);
          if (rafRef.current) cancelAnimationFrame(rafRef.current);
        };
      }, [gameStartTime]);

      // Haptic + sound at timer thresholds
      const timerInt = Math.floor(timer);
      useEffect(() => {
        if (phase !== 'timer' || timer >= 20) return;
        if (timerInt === 10) {
          haptic(30);
          sfx.tick();
        } else if (timerInt <= 5 && timerInt > 0) {
          haptic(20);
          sfx.tick();
        }
      }, [timerInt, phase]);

      // Auto-transition when timer hits 0
      useEffect(() => {
        if (timer === 0 && phase === 'timer') onDone();
      }, [timer, phase, onDone]);

      if (phase === 'pre') {
        return (
          <motion.div key="countdown-pre"
            initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0 }}
            transition={springConfig}
            role="alert"
            aria-live="assertive"
            style={{ minHeight: '100vh', background: 'var(--bg-primary)', display: 'flex', alignItems: 'center', justifyContent: 'center', position: 'relative' }}>
            {flash && <div style={{ position: 'absolute', inset: 0, background: 'rgba(52,211,153,0.25)', zIndex: 20 }} />}
            <AnimatePresence mode="wait">
              {!showGo ? (
                <motion.div key={preNum}
                  initial={{ scale: 0, opacity: 0 }}
                  animate={{ scale: 1, opacity: 1 }}
                  exit={{ scale: 2, opacity: 0 }}
                  transition={{ duration: 0.4 }}
                  style={{ fontSize: 120, fontWeight: 700, fontFamily: "'Space Mono', monospace", color: 'var(--cream)' }}>
                  {preNum}
                </motion.div>
              ) : (
                <motion.div key="go"
                  initial={{ scale: 0, opacity: 0 }}
                  animate={{ scale: 1, opacity: 1 }}
                  exit={{ scale: 2, opacity: 0 }}
                  transition={{ duration: 0.3 }}
                  style={{ fontSize: 100, fontWeight: 900, color: 'var(--emerald)' }}>
                  {goPhrase}
                </motion.div>
              )}
            </AnimatePresence>
          </motion.div>
        );
      }

      const isLow = timer <= 10;
      const isCritical = timer <= 5;

      return (
        <motion.div key="countdown-timer"
          initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0 }}
          transition={springConfig}
          style={{ minHeight: '100vh', background: 'var(--bg-primary)', display: 'flex', flexDirection: 'column', position: 'relative' }}
          className="safe-top safe-bottom">

          {/* Opponent left badge */}
          {soloFallback && (
            <div style={{ position: 'absolute', top: 16, left: 16, zIndex: 15, padding: '6px 12px', borderRadius: 100, background: 'rgba(239,68,68,0.15)', border: '1px solid rgba(239,68,68,0.25)', color: 'var(--accent-red)', fontSize: 11, fontWeight: 700 }}>
              OPPONENT LEFT
            </div>
          )}

          {/* PIP opponent (hidden in solo mode) */}
          {!soloMode && !soloFallback && (
            <div className="pip-video">
              {remoteStream ? <VideoFeed stream={remoteStream} mirrored /> : (
                <div style={{ width: '100%', height: '100%', display: 'flex', alignItems: 'center', justifyContent: 'center' }}>
                  <PulsingDots light />
                </div>
              )}
              {onToggleMute && <MuteButton isMuted={isMuted} onToggle={onToggleMute} />}
            </div>
          )}

          <div style={{ flex: 1, display: 'flex', flexDirection: 'column', alignItems: 'center', justifyContent: 'center' }}>
            <p className="t-label" style={{ marginBottom: 16 }}>TIME REMAINING</p>
            <div style={{ position: 'relative', display: 'flex', alignItems: 'center', justifyContent: 'center', width: 200, height: 200 }}>
              <TimerArc progress={timer / 20} />
              <div className={`t-hero ${isLow ? 'timer-pulse' : ''}`} style={{ fontSize: 48, color: isCritical ? 'var(--accent-red)' : 'var(--cream)', position: 'relative', zIndex: 1 }}>
                {timer.toFixed(1)}
              </div>
            </div>
            <p style={{ fontSize: 16, fontWeight: 500, color: 'var(--text-secondary)', marginTop: 12 }}>
              Stop exactly at the G
            </p>
          </div>

          <div className="layout" style={{ paddingBottom: 16 }}>
            <button className="btn-success" onClick={() => {
              if (rafRef.current) cancelAnimationFrame(rafRef.current);
              haptic(50);
              onDone();
            }}>I'm Done</button>
          </div>
        </motion.div>
      );
    }

    function WaitingScreen({ accuracy, resultImage, remoteStream, opponentSubmitted, timeoutEnd }) {
      const [countdown, setCountdown] = useState(() => {
        if (timeoutEnd) return Math.max(0, Math.ceil((timeoutEnd - Date.now()) / 1000));
        return 90;
      });

      useEffect(() => {
        if (opponentSubmitted) return;
        const interval = setInterval(() => {
          if (timeoutEnd) {
            const remaining = Math.max(0, Math.ceil((timeoutEnd - Date.now()) / 1000));
            setCountdown(remaining);
            if (remaining <= 0) clearInterval(interval);
          } else {
            setCountdown(c => {
              if (c <= 1) { clearInterval(interval); return 0; }
              return c - 1;
            });
          }
        }, 1000);
        return () => clearInterval(interval);
      }, [opponentSubmitted, timeoutEnd]);

      const progress = countdown / 90;
      const ringRadius = 22;
      const ringCircumference = 2 * Math.PI * ringRadius;
      const ringOffset = ringCircumference * (1 - progress);

      return (
        <motion.div key="waiting"
          initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0 }}
          transition={springConfig}
          style={{ minHeight: '100vh', background: 'var(--bg-primary)', display: 'flex', flexDirection: 'column', alignItems: 'center', justifyContent: 'center', position: 'relative' }}
          className="safe-top safe-bottom">

          <div className="pip-video">
            {remoteStream ? <VideoFeed stream={remoteStream} mirrored /> : null}
          </div>

          <div className="layout" style={{ textAlign: 'center' }}>
            <p className="t-label" style={{ marginBottom: 12 }}>YOUR ACCURACY</p>
            <div style={{ fontSize: 64, fontWeight: 700, fontFamily: "'Space Mono', monospace", color: accuracy !== null ? getAccuracyColor(accuracy) : 'var(--cream)', fontVariantNumeric: 'tabular-nums', marginBottom: 16 }}>
              {accuracy !== null ? <><RollingNumber value={accuracy} />%</> : '--'}
            </div>

            {resultImage && (
              <div style={{ marginBottom: 24 }}>
                <img src={resultImage} alt="Your result"
                  style={{ width: 120, height: 120, borderRadius: 16, objectFit: 'cover', border: '1px solid rgba(212,168,67,0.3)', boxShadow: '0 0 8px rgba(212,168,67,0.15)', margin: '0 auto', display: 'block' }} />
              </div>
            )}

            {opponentSubmitted ? (
              <>
                <div style={{ marginBottom: 8 }}>
                  <PulsingDots light />
                </div>
                <p style={{ fontSize: 14, fontWeight: 500, color: 'var(--emerald)' }}>
                  Opponent submitted! Preparing results...
                </p>
              </>
            ) : (
              <>
                <div style={{ position: 'relative', display: 'inline-flex', alignItems: 'center', justifyContent: 'center', marginBottom: 12 }}>
                  <svg width="56" height="56" viewBox="0 0 56 56" style={{ transform: 'rotate(-90deg)' }}>
                    <circle cx="28" cy="28" r={ringRadius} fill="none" stroke="rgba(52,211,153,0.1)" strokeWidth="3" />
                    <circle cx="28" cy="28" r={ringRadius} fill="none"
                      stroke={countdown > 20 ? 'var(--emerald)' : countdown > 10 ? 'var(--gold)' : 'var(--accent-red)'}
                      strokeWidth="3"
                      strokeDasharray={ringCircumference} strokeDashoffset={ringOffset}
                      strokeLinecap="round"
                      style={{ transition: 'stroke-dashoffset 1s linear, stroke 1s ease' }} />
                  </svg>
                  <span style={{
                    position: 'absolute',
                    fontSize: 14, fontWeight: 700,
                    fontFamily: "'Space Mono', monospace",
                    color: countdown > 20 ? 'var(--text-secondary)' : countdown > 10 ? 'var(--gold)' : 'var(--accent-red)',
                  }}>{countdown}</span>
                </div>
                {countdown > 0 ? (
                  <p style={{ fontSize: 14, fontWeight: 500, color: 'var(--text-secondary)' }}>
                    Waiting for opponent... ({countdown}s)
                  </p>
                ) : (
                  <div style={{ marginTop: 4 }}>
                    <p style={{ fontSize: 16, fontWeight: 700, color: 'var(--emerald)' }}>Opponent timed out &mdash; you win!</p>
                    <div style={{ marginTop: 8 }}><PulsingDots light /></div>
                    <p style={{ fontSize: 12, color: 'var(--text-secondary)', marginTop: 4 }}>Waiting for server confirmation...</p>
                  </div>
                )}
              </>
            )}
          </div>
        </motion.div>
      );
    }

    function RevealScreen({ revealData, playerId, onRematch, onNewOpponent, onCancelRematch, onNextRound, rematchRequested, rematchPending, onAcceptRematch, onDeclineRematch, stats, winRate, isRematch, seriesData }) {
      const [phase, setPhase] = useState(0);
      const [showConfetti, setShowConfetti] = useState(false);
      const [showPBCelebration, setShowPBCelebration] = useState(false);

      const { results, winnerId, player1Id, player2Id, opponentName: revealOpName } = revealData;
      const isWinner = winnerId === playerId;
      const isTie = winnerId === null;
      const opId = playerId === player1Id ? player2Id : player1Id;
      const myResult = results[playerId];
      const opResult = results[opId];
      const rank = getPlayerRank(stats.gamesPlayed, winRate);
      const opLabel = revealOpName || 'OPPONENT';
      const isNewPersonalBest = myResult.accuracy >= stats.bestAccuracy && myResult.accuracy > 0;
      const isCloseMatch = Math.abs(myResult.accuracy - opResult.accuracy) <= 5 && !isTie;

      useEffect(() => {
        // Standard timings
        const full = [0, 1000, 2500, 4000, 5500, 7000, 8500];
        const fast = [0, 400, 1000, 1600, 2200, 2800, 3400];
        // Extended dramatic timings for close matches (within 5%)
        const dramatic = [0, 1200, 3000, 5000, 7500, 10000, 11500];
        const timings = isRematch ? fast : (isCloseMatch ? dramatic : full);
        const timers = timings.map((delay, i) => setTimeout(() => setPhase(i), delay));
        const confettiDelay = isRematch ? 3200 : 7500;
        const confettiTimer = setTimeout(() => {
          // Confetti for winner OR personal best
          if (winnerId === playerId || isNewPersonalBest) {
            setShowConfetti(true);
            setTimeout(() => setShowConfetti(false), 2500);
          }
        }, confettiDelay);
        return () => { timers.forEach(clearTimeout); clearTimeout(confettiTimer); };
      }, [winnerId, playerId, isRematch, isNewPersonalBest]);

      // Sound + haptic on winner reveal
      useEffect(() => {
        if (phase === 5) {
          haptic([100, 50, 100]);
          if (isWinner) sfx.win();
          else if (!isTie) sfx.lose();
        }
        // Trigger personal best celebration when stats card shows
        if (phase === 6 && isNewPersonalBest) {
          setShowPBCelebration(true);
          haptic([50, 30, 50, 30, 100]);
          sfx.personalBest();
        }
      }, [phase, isNewPersonalBest]);

      const handleShare = useCallback(async () => {
        const text = isWinner
          ? `I won SPLIT IT with ${myResult.accuracy}% accuracy! (${rank.name} rank)`
          : `I scored ${myResult.accuracy}% on SPLIT IT! (${rank.name} rank)`;
        try { await navigator.share({ title: 'SPLIT IT', text }); } catch (e) {}
      }, [isWinner, myResult, rank]);

      return (
        <motion.div key="reveal"
          initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0 }}
          transition={springConfig}
          style={{ minHeight: '100vh', background: 'var(--bg-primary)', display: 'flex', flexDirection: 'column', position: 'relative' }}
          className="safe-top safe-bottom">

          {showConfetti && <ConfettiBurst />}

          {/* Emerald pulse glow on winner announce */}
          {phase >= 5 && isWinner && (
            <motion.div
              initial={{ opacity: 0 }}
              animate={{ opacity: [0, 0.8, 0, 0.5, 0] }}
              transition={{ duration: 2, ease: "easeInOut" }}
              style={{
                position: 'fixed', inset: 0,
                background: 'radial-gradient(circle at center, rgba(52,211,153,0.12) 0%, transparent 70%)',
                pointerEvents: 'none', zIndex: 0
              }}
            />
          )}

          {/* Gold pulse glow for personal best */}
          {showPBCelebration && (
            <motion.div
              initial={{ opacity: 0 }}
              animate={{ opacity: [0, 1, 0.3, 0.8, 0] }}
              transition={{ duration: 2.5, ease: "easeInOut" }}
              style={{
                position: 'fixed', inset: 0,
                background: 'radial-gradient(circle at center, rgba(212,168,67,0.2) 0%, transparent 60%)',
                pointerEvents: 'none', zIndex: 0
              }}
            />
          )}

          <div className="layout" style={{ flex: 1, display: 'flex', flexDirection: 'column', justifyContent: 'center', gap: 16, position: 'relative', zIndex: 1 }}>

            {/* Phase 0: Title */}
            {phase >= 0 && (
              <motion.div
                initial={{ opacity: 0, y: 10 }}
                animate={{ opacity: phase === 0 ? 1 : 0.4, y: 0 }}
                transition={springConfig}
                style={{ textAlign: 'center', marginBottom: 8 }}>
                <p style={{ fontSize: 16, fontWeight: 600, color: 'var(--text-secondary)' }}>The Results Are In</p>
              </motion.div>
            )}

            {/* Phase 1-2: Opponent card */}
            {phase >= 1 && (
              <motion.div
                initial={{ opacity: 0, y: 40 }}
                animate={{ opacity: 1, y: 0 }}
                transition={springConfig}
                className={phase >= 5 && !isTie && !isWinner ? 'animated-gold-border' : 'card-dark'}>
                <p className="t-label" style={{ marginBottom: 8 }}>{opLabel}</p>
                {opResult.image && (
                  <div style={{ marginBottom: 12 }}>
                    <img src={opResult.image} alt="Opponent"
                      style={{ width: '100%', height: 100, objectFit: 'cover', borderRadius: 12 }} />
                  </div>
                )}
                <div style={{ textAlign: 'center' }}>
                  {phase >= 2 ? (
                    <motion.div initial={{ scale: 0 }} animate={{ scale: 1 }}
                      transition={springConfig}
                      style={{ fontSize: 36, fontWeight: 700, fontFamily: "'Space Mono', monospace", color: getAccuracyColor(opResult.accuracy) }}>
                      <RollingNumber value={opResult.accuracy} />%
                    </motion.div>
                  ) : (
                    <div style={{ fontSize: 36, fontWeight: 700, fontFamily: "'Space Mono', monospace", color: 'var(--text-secondary)' }}>---</div>
                  )}
                </div>
              </motion.div>
            )}

            {/* Phase 3-4: My card */}
            {phase >= 3 && (
              <motion.div
                initial={{ opacity: 0, y: 40 }}
                animate={{ opacity: 1, y: 0 }}
                transition={springConfig}
                className={phase >= 5 && !isTie && isWinner ? 'animated-gold-border' : 'card-dark'}>
                <p className="t-label" style={{ marginBottom: 8 }}>YOU</p>
                <ResultImageWithOverlay
                  src={myResult.image}
                  liquidY={myResult.liquidY}
                  targetY={myResult.targetY}
                  height={myResult.height}
                  imgHeight={100}
                />
                <div style={{ textAlign: 'center' }}>
                  {phase >= 4 ? (
                    <motion.div initial={{ scale: 0 }} animate={{ scale: 1 }}
                      transition={springConfig}
                      style={{ fontSize: 36, fontWeight: 700, fontFamily: "'Space Mono', monospace", color: getAccuracyColor(myResult.accuracy) }}>
                      <RollingNumber value={myResult.accuracy} />%
                    </motion.div>
                  ) : (
                    <div style={{ fontSize: 36, fontWeight: 700, fontFamily: "'Space Mono', monospace", color: 'var(--text-secondary)' }}>---</div>
                  )}
                </div>
              </motion.div>
            )}

            {/* Phase 5: Winner announcement */}
            {phase >= 5 && (
              <motion.div
                initial={{ scale: 0 }}
                animate={{ scale: [0, 1.1, 1] }}
                transition={{ duration: 0.5 }}
                style={{ textAlign: 'center', padding: '16px 0' }}>
                {seriesData && seriesData.seriesOver ? (
                  <>
                    <div style={{
                      fontSize: 28, fontWeight: 900,
                      color: seriesData.seriesWinner === playerId ? 'var(--emerald)' : 'var(--accent-red)',
                      marginBottom: 4
                    }}>
                      {seriesData.seriesWinner === playerId ? 'SERIES WIN!' : 'SERIES LOST'}
                    </div>
                    <p style={{ fontSize: 14, fontWeight: 400, color: 'var(--text-secondary)' }}>
                      {seriesData.seriesWinner === playerId ? 'You took the best of 3!' : 'They took the best of 3'}
                    </p>
                  </>
                ) : (
                  <>
                    {isCloseMatch && (
                      <motion.div
                        initial={{ opacity: 0, scale: 0.8 }}
                        animate={{ opacity: 1, scale: 1 }}
                        transition={{ duration: 0.3, delay: 0.1 }}
                        style={{
                          fontSize: 12, fontWeight: 700, color: 'var(--gold)',
                          letterSpacing: '0.15em', marginBottom: 8,
                          padding: '4px 12px', background: 'rgba(212,168,67,0.15)',
                          borderRadius: 100, display: 'inline-block'
                        }}>
                        CLOSE MATCH!
                      </motion.div>
                    )}
                    <div style={{
                      fontSize: 28, fontWeight: 900,
                      color: isTie ? 'var(--text-secondary)' : isWinner ? 'var(--emerald)' : 'var(--accent-red)',
                      marginBottom: 4
                    }}>
                      {isTie ? "It's a Tie" : isWinner ? 'You Win' : 'You Lose'}
                    </div>
                    <p style={{ fontSize: 14, fontWeight: 400, color: 'var(--text-secondary)' }}>
                      {seriesData ? `Round ${seriesData.round} of 3` : (isCloseMatch ? `By just ${Math.abs(myResult.accuracy - opResult.accuracy)}%!` : (isTie ? 'Perfectly matched!' : isWinner ? 'Superior split!' : 'Better luck next time'))}
                    </p>
                  </>
                )}
              </motion.div>
            )}

            {/* Series score bar */}
            {phase >= 5 && seriesData && (
              <motion.div initial={{ opacity: 0, y: 10 }} animate={{ opacity: 1, y: 0 }} transition={springConfig}>
                <SeriesScoreBar
                  myScore={seriesData.score[playerId] || 0}
                  opScore={seriesData.score[opId] || 0}
                  round={seriesData.round}
                  opponentName={opLabel} />
              </motion.div>
            )}

            {/* Phase 6: Stats update card */}
            {phase >= 6 && (
              <motion.div initial={{ opacity: 0, y: 20 }} animate={{ opacity: 1, y: 0 }}
                transition={springConfig}
                className="card-dark" style={{ padding: 16 }}>
                <p className="t-label" style={{ marginBottom: 12, textAlign: 'center' }}>YOUR RECORD</p>
                <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr 1fr', gap: 8, textAlign: 'center' }}>
                  <div>
                    <div style={{ fontSize: 11, color: 'var(--text-secondary)', marginBottom: 2 }}>W-L-T</div>
                    <div style={{ fontSize: 16, fontWeight: 700, fontFamily: "'Space Mono', monospace", color: 'var(--cream)' }}>
                      {stats.wins}-{stats.losses}-{stats.ties}
                    </div>
                  </div>
                  <div>
                    <div style={{ fontSize: 11, color: 'var(--text-secondary)', marginBottom: 2 }}>WIN RATE</div>
                    <div style={{ fontSize: 16, fontWeight: 700, fontFamily: "'Space Mono', monospace", color: winRate >= 50 ? 'var(--emerald)' : 'var(--text-secondary)' }}>
                      {winRate}%
                    </div>
                  </div>
                  <div>
                    <div style={{ fontSize: 11, color: 'var(--text-secondary)', marginBottom: 2 }}>STREAK</div>
                    <div style={{ fontSize: 16, fontWeight: 700, fontFamily: "'Space Mono', monospace", color: stats.currentStreak > 0 ? 'var(--emerald)' : 'var(--text-secondary)' }}>
                      {stats.currentStreak}
                    </div>
                  </div>
                </div>
                {isNewPersonalBest && (
                  <motion.div
                    initial={{ scale: 0, opacity: 0 }}
                    animate={{ scale: showPBCelebration ? [1, 1.1, 1] : 0, opacity: showPBCelebration ? 1 : 0 }}
                    transition={{ duration: 0.5, ease: 'easeOut' }}
                    style={{
                      marginTop: 12, textAlign: 'center', padding: '10px 16px',
                      background: 'linear-gradient(135deg, rgba(212,168,67,0.2) 0%, rgba(245,230,200,0.15) 100%)',
                      borderRadius: 12, border: '2px solid var(--gold)',
                      boxShadow: '0 0 20px rgba(212,168,67,0.3)'
                    }}>
                    <div style={{ fontSize: 10, fontWeight: 600, color: 'var(--cream)', letterSpacing: '0.1em', marginBottom: 2 }}>
                      NEW PERSONAL BEST
                    </div>
                    <div style={{ fontSize: 24, fontWeight: 900, color: 'var(--gold)', fontFamily: "'Space Mono', monospace" }}>
                      {myResult.accuracy}%
                    </div>
                  </motion.div>
                )}
                {stats.currentStreak > 1 && stats.currentStreak === stats.bestStreak && isWinner && (
                  <div style={{ marginTop: 8, textAlign: 'center', padding: '6px 12px', background: 'rgba(52,211,153,0.1)', borderRadius: 8, color: 'var(--emerald)', fontSize: 12, fontWeight: 700 }}>
                    NEW BEST STREAK: {stats.bestStreak}
                  </div>
                )}
                <div style={{ textAlign: 'center', marginTop: 8, fontSize: 12, color: rank.color, fontWeight: 600 }}>
                  {rank.icon} {rank.name} Rank
                </div>
              </motion.div>
            )}

            {/* Post-game actions */}
            {phase >= 6 && (
              <motion.div initial={{ opacity: 0, y: 20 }} animate={{ opacity: 1, y: 0 }}
                transition={springConfig}
                style={{ display: 'flex', flexDirection: 'column', gap: 12, marginTop: 8 }}>

                {seriesData && !seriesData.seriesOver ? (
                  /* Best-of-3 series in progress — show Next Round */
                  <>
                    <button className="btn-success" onClick={() => { haptic(30); onNextRound(); }}
                      style={{ fontSize: 16, fontWeight: 700, padding: '14px 0' }}>
                      Next Round
                    </button>
                    <button className="btn-text" style={{ color: 'var(--text-secondary)', textAlign: 'center' }} onClick={() => { haptic(20); onNewOpponent(); }}>
                      Forfeit Series
                    </button>
                  </>
                ) : rematchPending ? (
                  <div className="card-dark" style={{ textAlign: 'center' }}>
                    <p style={{ color: 'var(--text-primary)', fontWeight: 600, marginBottom: 12 }}>Opponent wants a rematch!</p>
                    <div style={{ display: 'flex', gap: 12 }}>
                      <button className="btn-success" style={{ flex: 1 }} onClick={() => { haptic([50, 30, 50]); onAcceptRematch(); }}>Accept</button>
                      <button className="btn-primary-light" style={{ flex: 1 }} onClick={() => { haptic(20); onDeclineRematch(); }}>Decline</button>
                    </div>
                  </div>
                ) : (
                  <>
                    {rematchRequested ? (
                      <div className="card-dark" style={{ textAlign: 'center', padding: 16 }}>
                        <PulsingDots light />
                        <p style={{ fontSize: 14, fontWeight: 600, color: 'var(--gold)', marginTop: 8 }}>Rematch requested</p>
                        <p style={{ fontSize: 12, color: 'var(--text-secondary)', marginTop: 4 }}>Waiting for opponent to respond...</p>
                        <button className="btn-text" style={{ color: 'var(--text-secondary)', marginTop: 12 }}
                          onClick={() => { haptic(20); onCancelRematch(); }}>
                          Cancel
                        </button>
                      </div>
                    ) : (
                      <button className="btn-primary-light" onClick={() => { haptic(30); onRematch(); }}>Rematch</button>
                    )}
                    <button className="btn-text" style={{ color: 'var(--text-secondary)', textAlign: 'center' }} onClick={() => { haptic(20); onNewOpponent(); }}>
                      New Opponent
                    </button>
                    {typeof navigator.share === 'function' && (
                      <button className="btn-text" style={{ color: 'var(--gold)', textAlign: 'center' }} onClick={() => { haptic(20); handleShare(); }}>
                        Share Result
                      </button>
                    )}
                  </>
                )}
              </motion.div>
            )}
          </div>
        </motion.div>
      );
    }

    function SoloRevealScreen({ accuracy, resultImage, liquidY, targetY, imageHeight, onPlayAgain, onHome, stats, winRate }) {
      const [phase, setPhase] = useState(0);
      const [showConfetti, setShowConfetti] = useState(false);
      const [showPBCelebration, setShowPBCelebration] = useState(false);
      const rank = getPlayerRank(stats.gamesPlayed, winRate);
      const isGood = accuracy >= 50;
      const isNewPersonalBest = accuracy >= stats.bestAccuracy && accuracy > 0;

      useEffect(() => {
        const timings = [0, 1500, 3000, 4500];
        const timers = timings.map((delay, i) => setTimeout(() => setPhase(i), delay));
        // Confetti for high accuracy or personal best
        if (accuracy >= 80 || isNewPersonalBest) {
          const confettiTimer = setTimeout(() => {
            setShowConfetti(true);
            setTimeout(() => setShowConfetti(false), 2500);
          }, 3500);
          timers.push(confettiTimer);
        }
        return () => timers.forEach(clearTimeout);
      }, [accuracy, isNewPersonalBest]);

      useEffect(() => {
        if (phase === 2) {
          haptic([100, 50, 100]);
          if (isGood) sfx.win(); else sfx.lose();
        }
        // Trigger personal best celebration when stats card shows
        if (phase === 3 && isNewPersonalBest) {
          setShowPBCelebration(true);
          haptic([50, 30, 50, 30, 100]);
          sfx.personalBest();
        }
      }, [phase, isNewPersonalBest]);

      const handleShare = useCallback(async () => {
        const text = `I scored ${accuracy}% on SPLIT IT! (${rank.name} rank)`;
        try { await navigator.share({ title: 'SPLIT IT', text }); } catch (e) {}
      }, [accuracy, rank]);

      const tierLabel = accuracy >= 97 ? 'GUINNESS GOD' : accuracy >= 80 ? 'Excellent' : accuracy >= 50 ? 'Decent Split' : accuracy >= 25 ? 'Needs Work' : 'Shocking';
      const tierColor = getAccuracyColor(accuracy);

      return (
        <motion.div key="solo-reveal"
          initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0 }}
          transition={springConfig}
          style={{ minHeight: '100vh', background: 'var(--bg-primary)', display: 'flex', flexDirection: 'column', position: 'relative' }}
          className="safe-top safe-bottom">

          {showConfetti && <ConfettiBurst />}

          {phase >= 2 && isGood && (
            <motion.div initial={{ opacity: 0 }} animate={{ opacity: [0, 0.8, 0, 0.5, 0] }}
              transition={{ duration: 2, ease: "easeInOut" }}
              style={{ position: 'fixed', inset: 0, background: 'radial-gradient(circle at center, rgba(52,211,153,0.12) 0%, transparent 70%)', pointerEvents: 'none', zIndex: 0 }} />
          )}

          {/* Gold pulse glow for personal best */}
          {showPBCelebration && (
            <motion.div
              initial={{ opacity: 0 }}
              animate={{ opacity: [0, 1, 0.3, 0.8, 0] }}
              transition={{ duration: 2.5, ease: "easeInOut" }}
              style={{
                position: 'fixed', inset: 0,
                background: 'radial-gradient(circle at center, rgba(212,168,67,0.2) 0%, transparent 60%)',
                pointerEvents: 'none', zIndex: 0
              }}
            />
          )}

          <div className="layout" style={{ flex: 1, display: 'flex', flexDirection: 'column', justifyContent: 'center', gap: 16, position: 'relative', zIndex: 1 }}>

            {phase >= 0 && (
              <motion.div initial={{ opacity: 0, y: 10 }} animate={{ opacity: 1, y: 0 }} transition={springConfig}
                style={{ textAlign: 'center', marginBottom: 8 }}>
                <p style={{ fontSize: 14, fontWeight: 600, color: 'var(--text-secondary)', letterSpacing: '0.05em' }}>SOLO CHALLENGE</p>
              </motion.div>
            )}

            {phase >= 1 && (
              <motion.div initial={{ opacity: 0, y: 40 }} animate={{ opacity: 1, y: 0 }} transition={springConfig}
                className="card-dark">
                <ResultImageWithOverlay
                  src={resultImage}
                  liquidY={liquidY}
                  targetY={targetY}
                  height={imageHeight}
                  imgHeight={120}
                />
                <div style={{ textAlign: 'center' }}>
                  <p className="t-label" style={{ marginBottom: 8 }}>YOUR ACCURACY</p>
                  <motion.div initial={{ scale: 0 }} animate={{ scale: 1 }} transition={springConfig}
                    style={{ fontSize: 48, fontWeight: 700, fontFamily: "'Space Mono', monospace", color: tierColor }}>
                    <RollingNumber value={accuracy} />%
                  </motion.div>
                </div>
              </motion.div>
            )}

            {phase >= 2 && (
              <motion.div initial={{ scale: 0 }} animate={{ scale: [0, 1.1, 1] }} transition={{ duration: 0.5 }}
                style={{ textAlign: 'center', padding: '12px 0' }}>
                <div style={{ fontSize: 24, fontWeight: 900, color: tierColor, marginBottom: 4 }}>
                  {tierLabel}
                </div>
              </motion.div>
            )}

            {phase >= 3 && (
              <motion.div initial={{ opacity: 0, y: 20 }} animate={{ opacity: 1, y: 0 }} transition={springConfig}
                className="card-dark" style={{ padding: 16 }}>
                <p className="t-label" style={{ marginBottom: 12, textAlign: 'center' }}>YOUR RECORD</p>
                <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr 1fr', gap: 8, textAlign: 'center' }}>
                  <div>
                    <div style={{ fontSize: 11, color: 'var(--text-secondary)', marginBottom: 2 }}>W-L-T</div>
                    <div style={{ fontSize: 16, fontWeight: 700, fontFamily: "'Space Mono', monospace", color: 'var(--cream)' }}>
                      {stats.wins}-{stats.losses}-{stats.ties}
                    </div>
                  </div>
                  <div>
                    <div style={{ fontSize: 11, color: 'var(--text-secondary)', marginBottom: 2 }}>WIN RATE</div>
                    <div style={{ fontSize: 16, fontWeight: 700, fontFamily: "'Space Mono', monospace", color: winRate >= 50 ? 'var(--emerald)' : 'var(--text-secondary)' }}>
                      {winRate}%
                    </div>
                  </div>
                  <div>
                    <div style={{ fontSize: 11, color: 'var(--text-secondary)', marginBottom: 2 }}>BEST ACC</div>
                    <div style={{ fontSize: 16, fontWeight: 700, fontFamily: "'Space Mono', monospace", color: getAccuracyColor(stats.bestAccuracy) }}>
                      {stats.bestAccuracy}%
                    </div>
                  </div>
                </div>
                {isNewPersonalBest && (
                  <motion.div
                    initial={{ scale: 0, opacity: 0 }}
                    animate={{ scale: showPBCelebration ? [1, 1.1, 1] : 0, opacity: showPBCelebration ? 1 : 0 }}
                    transition={{ duration: 0.5, ease: 'easeOut' }}
                    style={{
                      marginTop: 12, textAlign: 'center', padding: '10px 16px',
                      background: 'linear-gradient(135deg, rgba(212,168,67,0.2) 0%, rgba(245,230,200,0.15) 100%)',
                      borderRadius: 12, border: '2px solid var(--gold)',
                      boxShadow: '0 0 20px rgba(212,168,67,0.3)'
                    }}>
                    <div style={{ fontSize: 10, fontWeight: 600, color: 'var(--cream)', letterSpacing: '0.1em', marginBottom: 2 }}>
                      NEW PERSONAL BEST
                    </div>
                    <div style={{ fontSize: 24, fontWeight: 900, color: 'var(--gold)', fontFamily: "'Space Mono', monospace" }}>
                      {accuracy}%
                    </div>
                  </motion.div>
                )}
                <div style={{ textAlign: 'center', marginTop: 8, fontSize: 12, color: rank.color, fontWeight: 600 }}>
                  {rank.icon} {rank.name} Rank
                </div>
              </motion.div>
            )}

            {phase >= 3 && (
              <motion.div initial={{ opacity: 0, y: 20 }} animate={{ opacity: 1, y: 0 }} transition={springConfig}
                style={{ display: 'flex', flexDirection: 'column', gap: 12, marginTop: 8 }}>
                <button className="btn-primary" onClick={() => { haptic(30); onPlayAgain(); }}>Play Again</button>
                <button className="btn-text" style={{ color: 'var(--text-secondary)', textAlign: 'center' }} onClick={() => { haptic(20); onHome(); }}>Home</button>
                {typeof navigator.share === 'function' && (
                  <button className="btn-text" style={{ color: 'var(--gold)', textAlign: 'center' }} onClick={() => { haptic(20); handleShare(); }}>Share Result</button>
                )}
              </motion.div>
            )}
          </div>
        </motion.div>
      );
    }

    // ============ MAIN APP ============

    const initialGameState = {
      screen: 'landing',
      roomId: null,
      playerId: null,
      opponentId: null,
      opponentName: null,
      isInitiator: false,
      myReady: false,
      opponentReady: false,
      gameStartTime: null,
      opponentPintImage: null,
      myResult: null,
      opponentSubmitted: false,
      revealData: null,
      capturedResultImage: null,
      isScanning: false,
      soloMode: false,
      soloFallback: false,
      timeoutEnd: null,
      rematchRequested: false,
      rematchPending: false,
      isRematch: false,
      seriesMode: 'single',
      seriesData: null,
    };

    function gameReducer(state, action) {
      switch (action.type) {
        case 'SET_SCREEN':
          return { ...state, screen: action.screen };
        case 'MATCHED':
          return { ...state, roomId: action.roomId, playerId: action.playerId, opponentId: action.opponentId, opponentName: action.opponentName || null, isInitiator: action.isInitiator, opponentPintImage: action.opponentPintImage || null, seriesMode: action.mode || 'single', screen: 'matched' };
        case 'UPDATE_PLAYER_ID':
          return { ...state, playerId: action.playerId };
        case 'SET_SERIES_MODE':
          return { ...state, seriesMode: action.mode };
        case 'READY_UPDATE':
          return { ...state, myReady: action.myReady !== undefined ? action.myReady : state.myReady, opponentReady: action.opponentReady !== undefined ? action.opponentReady : state.opponentReady };
        case 'SET_MY_READY':
          return { ...state, myReady: true };
        case 'GAME_START':
          return { ...state, gameStartTime: action.countdownStart, screen: 'countdown' };
        case 'OPPONENT_SUBMITTED':
          return { ...state, opponentSubmitted: true, timeoutEnd: action.timeoutEnd || state.timeoutEnd };
        case 'SET_TIMEOUT_END':
          return { ...state, timeoutEnd: action.timeoutEnd };
        case 'REVEAL_START':
          return { ...state, revealData: action.data, seriesData: action.data.series || null, screen: 'reveal' };
        case 'NEXT_ROUND':
          return { ...state, myReady: false, opponentReady: false, myResult: null, opponentSubmitted: false, revealData: null, capturedResultImage: null, isScanning: false, timeoutEnd: null, isRematch: true, screen: 'countdown', gameStartTime: action.countdownStart };
        case 'SET_SOLO_MODE':
          return { ...state, soloMode: true, gameStartTime: action.gameStartTime, screen: 'countdown' };
        case 'SET_MY_RESULT':
          return { ...state, myResult: action.result };
        case 'SET_CAPTURED_RESULT':
          return { ...state, capturedResultImage: action.image, isScanning: action.isScanning !== undefined ? action.isScanning : state.isScanning };
        case 'SET_SCANNING':
          return { ...state, isScanning: action.isScanning };
        case 'SET_REMATCH_STATE':
          return { ...state, rematchRequested: action.requested !== undefined ? action.requested : state.rematchRequested, rematchPending: action.pending !== undefined ? action.pending : state.rematchPending };
        case 'REMATCH_ACCEPTED':
          return { ...state, myReady: false, opponentReady: false, myResult: null, opponentSubmitted: false, revealData: null, rematchRequested: false, rematchPending: false, capturedResultImage: null, isScanning: false, timeoutEnd: null, isRematch: true, soloFallback: false, screen: 'ready' };
        case 'LEAVE_ROOM':
          return { ...initialGameState };
        case 'SOLO_HOME':
          return { ...state, soloMode: false, myResult: null, capturedResultImage: null, isScanning: false, timeoutEnd: null, screen: 'landing' };
        case 'SOLO_PLAY_AGAIN':
          return { ...state, myResult: null, capturedResultImage: null, isScanning: false, gameStartTime: action.gameStartTime, screen: 'countdown' };
        case 'SET_SOLO_CONTINUE':
          return { ...state, soloMode: true, soloFallback: true };
        default:
          return state;
      }
    }

    function App() {
      const { socket, connected } = useSocket();
      const { stats, recordGame, winRate } = useStats();
      const { nickname, setNickname } = useNickname();
      const leaderboard = useLeaderboard();
      const [preferredMode, setPreferredMode] = useState('single');

      const [g, dispatch] = useReducer(gameReducer, initialGameState);

      // Toast (kept separate — high-frequency, UI-only)
      const [toastMsg, setToastMsg] = useState(null);
      const [toastType, setToastType] = useState('info');
      const [toastVisible, setToastVisible] = useState(false);

      const canvasRef = useRef(null);
      const screenRef = useRef(g.screen);
      const myResultRef = useRef(g.myResult);
      const soloModeRef = useRef(g.soloMode);
      const { analyze } = usePintAnalysis();

      // Keep refs in sync
      useEffect(() => { screenRef.current = g.screen; }, [g.screen]);
      useEffect(() => { myResultRef.current = g.myResult; }, [g.myResult]);
      useEffect(() => { soloModeRef.current = g.soloMode; }, [g.soloMode]);

      // WebRTC
      const webrtc = useWebRTC(socket, g.opponentId, g.isInitiator);

      const showToast = useCallback((msg, type = 'info') => {
        setToastMsg(msg);
        setToastType(type);
        setToastVisible(true);
        setTimeout(() => setToastVisible(false), 3000);
      }, []);

      // Track stats on reveal
      useEffect(() => {
        if (g.revealData && g.playerId) {
          const myRes = g.revealData.results[g.playerId];
          const accuracy = myRes ? myRes.accuracy : 0;
          if (g.revealData.winnerId === g.playerId) recordGame({ outcome: 'win', accuracy });
          else if (g.revealData.winnerId === null) recordGame({ outcome: 'tie', accuracy });
          else recordGame({ outcome: 'loss', accuracy });
          leaderboard.addEntry(nickname || 'Anon', accuracy);
        }
      }, [g.revealData, g.playerId, recordGame]);

      // Auto-rejoin room on socket reconnect
      useEffect(() => {
        if (!socket) return;
        const onReconnect = () => {
          if (g.roomId && g.playerId) {
            socket.emit('rejoin-room', { roomId: g.roomId, oldSocketId: g.playerId });
            dispatch({ type: 'UPDATE_PLAYER_ID', playerId: socket.id });
          }
        };
        socket.io.on('reconnect', onReconnect);
        return () => socket.io.off('reconnect', onReconnect);
      }, [socket, g.roomId, g.playerId]);

      // Clean up WebRTC on rematch
      useEffect(() => {
        if (g.screen === 'ready' && g.isRematch) {
          webrtc.cleanup();
        }
      }, [g.screen, g.isRematch]);

      const handleLeaveRoom = useCallback(() => {
        webrtc.cleanup();
        if (socket) socket.emit('leave-room');
        dispatch({ type: 'LEAVE_ROOM' });
      }, [socket, webrtc]);

      // ---- Socket events ----
      useEffect(() => {
        if (!socket) return;

        const onMatched = (data) => {
          dispatch({ type: 'MATCHED', roomId: data.roomId, playerId: data.playerId, opponentId: data.opponentId, opponentName: data.opponentName, isInitiator: data.isInitiator, opponentPintImage: data.opponentPintImage, mode: data.mode });
        };

        const onReadyUpdate = (data) => {
          const myId = socket.id;
          const oppId = Object.keys(data.readyState).find(id => id !== myId);
          dispatch({ type: 'READY_UPDATE', myReady: data.readyState[myId], opponentReady: oppId ? data.readyState[oppId] : false });
        };

        const onGameStart = (data) => {
          // Handle both initial game start and next-round start
          if (screenRef.current === 'reveal') {
            // Next round in best-of-3
            dispatch({ type: 'NEXT_ROUND', countdownStart: data.countdownStart });
          } else {
            dispatch({ type: 'GAME_START', countdownStart: data.countdownStart });
          }
        };

        const onOpponentSubmitted = (data) => {
          dispatch({ type: 'OPPONENT_SUBMITTED', timeoutEnd: data && data.timeoutEnd ? data.timeoutEnd : null });
        };

        const onSubmitAck = (data) => {
          if (data && data.timeoutEnd) dispatch({ type: 'SET_TIMEOUT_END', timeoutEnd: data.timeoutEnd });
        };

        const onRevealStart = (data) => {
          dispatch({ type: 'REVEAL_START', data });
        };

        const onServerError = (data) => {
          showToast(data && data.message ? data.message : 'Server error', 'error');
        };

        const onRejoinSuccess = () => {
          showToast('Reconnected to game');
        };

        const onRejoinFailed = () => {
          showToast('Failed to rejoin game', 'error');
          handleLeaveRoom();
        };

        const onRematchRequested = () => dispatch({ type: 'SET_REMATCH_STATE', pending: true });

        const onRematchAccepted = () => {
          dispatch({ type: 'REMATCH_ACCEPTED' });
        };

        const onRematchDeclined = () => {
          dispatch({ type: 'SET_REMATCH_STATE', requested: false });
          showToast('Opponent declined rematch', 'error');
        };

        const handleOpponentGone = (label) => {
          const s = screenRef.current;
          const activeScreens = ['countdown', 'capture-result', 'drinking'];
          if (activeScreens.includes(s)) {
            dispatch({ type: 'SET_SOLO_CONTINUE' });
            showToast(`${label} \u2014 continuing solo`);
            return;
          }
          if (s === 'waiting' && myResultRef.current) {
            dispatch({ type: 'SET_SOLO_CONTINUE' });
            recordGame({ outcome: 'win', accuracy: myResultRef.current.accuracy });
            showToast(`${label} \u2014 you win!`);
            dispatch({ type: 'SET_SCREEN', screen: 'solo-reveal' });
            return;
          }
          showToast(label, 'error');
          handleLeaveRoom();
        };

        const onOpponentDisconnected = () => handleOpponentGone('Opponent disconnected');
        const onOpponentLeft = () => handleOpponentGone('Opponent left the game');

        socket.on('matched', onMatched);
        socket.on('ready-update', onReadyUpdate);
        socket.on('game-start', onGameStart);
        socket.on('opponent-submitted', onOpponentSubmitted);
        socket.on('submit-ack', onSubmitAck);
        socket.on('reveal-start', onRevealStart);
        socket.on('rematch-requested', onRematchRequested);
        socket.on('rematch-accepted', onRematchAccepted);
        socket.on('rematch-declined', onRematchDeclined);
        socket.on('opponent-disconnected', onOpponentDisconnected);
        socket.on('opponent-left', onOpponentLeft);
        socket.on('error', onServerError);
        socket.on('rejoin-success', onRejoinSuccess);
        socket.on('rejoin-failed', onRejoinFailed);

        return () => {
          socket.off('matched', onMatched);
          socket.off('ready-update', onReadyUpdate);
          socket.off('game-start', onGameStart);
          socket.off('opponent-submitted', onOpponentSubmitted);
          socket.off('submit-ack', onSubmitAck);
          socket.off('reveal-start', onRevealStart);
          socket.off('rematch-requested', onRematchRequested);
          socket.off('rematch-accepted', onRematchAccepted);
          socket.off('rematch-declined', onRematchDeclined);
          socket.off('opponent-disconnected', onOpponentDisconnected);
          socket.off('opponent-left', onOpponentLeft);
          socket.off('error', onServerError);
          socket.off('rejoin-success', onRejoinSuccess);
          socket.off('rejoin-failed', onRejoinFailed);
        };
      }, [socket, showToast, handleLeaveRoom]);

      // Start WebRTC when matched
      useEffect(() => {
        if (g.screen === 'matched' && socket && g.opponentId) {
          webrtc.start();
        }
      }, [g.screen, socket, g.opponentId]);

      // ---- Handlers ----
      const handleGetStarted = () => {
        dispatch({ type: 'SET_SCREEN', screen: 'searching' });
        if (socket) socket.emit('join-queue', { nickname: nickname || 'Anon', mode: preferredMode });
      };

      const handleQuickPlay = () => {
        dispatch({ type: 'SET_SCREEN', screen: 'searching' });
        if (socket) socket.emit('join-queue', { nickname: nickname || 'Anon', mode: preferredMode });
      };

      const handleSoloMode = useCallback(() => {
        if (socket) socket.emit('leave-queue');
        dispatch({ type: 'SET_SOLO_MODE', gameStartTime: Date.now() + 3000 });
        showToast('Solo mode activated', 'info');
      }, [socket, showToast]);

      const handleCancelSearch = () => {
        if (socket) socket.emit('leave-queue');
        dispatch({ type: 'SET_SCREEN', screen: 'landing' });
      };

      const handleMatchedContinue = () => dispatch({ type: 'SET_SCREEN', screen: 'ready' });

      const handleReady = () => {
        if (socket) socket.emit('player-ready');
        dispatch({ type: 'SET_MY_READY' });
      };

      const handleDrinkingDone = useCallback(() => dispatch({ type: 'SET_SCREEN', screen: 'capture-result' }), []);

      const handleResultCaptured = async (img) => {
        dispatch({ type: 'SET_CAPTURED_RESULT', image: img, isScanning: true });

        // Wait for scan animation, then analyze
        setTimeout(async () => {
          const canvas = canvasRef.current;
          const analysis = await analyze(img, canvas);
          dispatch({ type: 'SET_SCANNING', isScanning: false });
          dispatch({ type: 'SET_MY_RESULT', result: { ...analysis, image: img } });

          if (soloModeRef.current) {
            const outcome = analysis.accuracy >= 50 ? 'win' : 'loss';
            recordGame({ outcome, accuracy: analysis.accuracy });
            leaderboard.addEntry(nickname || 'Anon', analysis.accuracy);
            dispatch({ type: 'SET_SCREEN', screen: 'solo-reveal' });
          } else {
            const compressed = await compressImage(img);
            if (socket) socket.emit('submit-result', { image: compressed, accuracy: analysis.accuracy });
            dispatch({ type: 'SET_SCREEN', screen: 'waiting' });
          }
        }, 1800);
      };

      const handleRematch = () => {
        dispatch({ type: 'SET_REMATCH_STATE', requested: true });
        if (socket) socket.emit('request-rematch');
      };

      const handleAcceptRematch = () => {
        if (socket) socket.emit('accept-rematch');
      };

      const handleDeclineRematch = () => {
        if (socket) socket.emit('decline-rematch');
        dispatch({ type: 'SET_REMATCH_STATE', pending: false });
      };

      const handleNextRound = () => {
        if (socket) socket.emit('next-round-ready');
      };

      const handleCancelRematch = () => {
        dispatch({ type: 'SET_REMATCH_STATE', requested: false });
      };

      const handleNewOpponent = () => {
        handleLeaveRoom();
        setTimeout(() => {
          dispatch({ type: 'SET_SCREEN', screen: 'searching' });
          if (socket) socket.emit('join-queue', { nickname: nickname || 'Anon', mode: preferredMode });
        }, 100);
      };

      const handleSoloPlayAgain = () => {
        dispatch({ type: 'SOLO_PLAY_AGAIN', gameStartTime: Date.now() + 3000 });
      };

      const handleSoloHome = () => {
        dispatch({ type: 'SOLO_HOME' });
      };

      return (
        <div style={{ minHeight: '100vh' }}>
          <LandscapeWarning />
          <canvas ref={canvasRef} style={{ display: 'none' }} />
          <Toast message={toastMsg} type={toastType} visible={toastVisible} />
          <ConnectionBanner connected={connected} />

          <AnimatePresence mode="wait">
            {g.screen === 'landing' && (
              <LandingScreen key="landing" onStart={handleGetStarted} onQuickPlay={handleQuickPlay} stats={stats} winRate={winRate}
                nickname={nickname} onSetNickname={setNickname} leaderboardEntries={leaderboard.entries} />
            )}

            {g.screen === 'searching' && (
              <SearchingScreen key="searching" onCancel={handleCancelSearch} onSolo={handleSoloMode} />
            )}

            {g.screen === 'matched' && (
              <MatchedScreen key="matched"
                localStream={webrtc.localStream}
                remoteStream={webrtc.remoteStream}
                connectionState={webrtc.connectionState}
                webrtcError={webrtc.error}
                onRetryWebRTC={webrtc.retry}
                onReady={handleMatchedContinue}
                isMuted={webrtc.isMuted}
                onToggleMute={webrtc.toggleMute}
                opponentPintImage={g.opponentPintImage} />
            )}

            {g.screen === 'ready' && (
              <ReadyScreen key="ready"
                localStream={webrtc.localStream}
                remoteStream={webrtc.remoteStream}
                myReady={g.myReady}
                opponentReady={g.opponentReady}
                onReady={handleReady}
                isMuted={webrtc.isMuted}
                onToggleMute={webrtc.toggleMute} />
            )}

            {g.screen === 'countdown' && (
              <CountdownScreen key="countdown"
                gameStartTime={g.gameStartTime}
                remoteStream={webrtc.remoteStream}
                onDone={handleDrinkingDone}
                soloMode={g.soloMode}
                soloFallback={g.soloFallback}
                isMuted={webrtc.isMuted}
                onToggleMute={webrtc.toggleMute} />
            )}

            {g.screen === 'capture-result' && (
              <CaptureScreen key="capture-result" mode="result"
                onCapture={handleResultCaptured}
                capturedImage={g.capturedResultImage}
                isScanning={g.isScanning}
                remoteStream={!g.soloMode ? webrtc.remoteStream : null} />
            )}

            {g.screen === 'waiting' && (
              <WaitingScreen key="waiting"
                accuracy={g.myResult?.accuracy ?? null}
                resultImage={g.myResult?.image}
                remoteStream={webrtc.remoteStream}
                opponentSubmitted={g.opponentSubmitted}
                timeoutEnd={g.timeoutEnd} />
            )}

            {g.screen === 'reveal' && g.revealData && (
              <RevealScreen key="reveal"
                revealData={{...g.revealData, opponentName: g.opponentName}}
                playerId={g.playerId}
                onRematch={handleRematch}
                onNewOpponent={handleNewOpponent}
                onCancelRematch={handleCancelRematch}
                rematchRequested={g.rematchRequested}
                rematchPending={g.rematchPending}
                onAcceptRematch={handleAcceptRematch}
                onDeclineRematch={handleDeclineRematch}
                stats={stats}
                winRate={winRate}
                isRematch={g.isRematch}
                seriesData={g.seriesData}
                onNextRound={handleNextRound} />
            )}

            {g.screen === 'solo-reveal' && g.myResult && (
              <SoloRevealScreen key="solo-reveal"
                accuracy={g.myResult.accuracy}
                resultImage={g.myResult.image}
                liquidY={g.myResult.liquidY}
                targetY={g.myResult.targetY}
                imageHeight={g.myResult.height}
                onPlayAgain={handleSoloPlayAgain}
                onHome={handleSoloHome}
                stats={stats}
                winRate={winRate} />
            )}
          </AnimatePresence>
        </div>
      );
    }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
    const splash = document.getElementById('splash');
    if (splash) splash.remove();
  </script>
</body>
</html>
