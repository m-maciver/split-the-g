<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="theme-color" content="#0B1A0E">
  <link rel="manifest" href="manifest.json">
  <title>Split the G</title>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://unpkg.com/framer-motion@10/dist/framer-motion.js"></script>
  <script src="/socket.io/socket.io.js"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=DM+Sans:wght@400;500;600;700;800;900&family=Space+Mono:wght@400;700&display=swap');

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }

    :root {
      --bg-primary: #0B1A0E;
      --bg-elevated: #132A18;
      --bg-surface: #1A3520;
      --cream: #F5E6C8;
      --gold: #D4A843;
      --emerald: #34D399;
      --text-primary: #F0EBE0;
      --text-secondary: #7C9A82;
      --accent-red: #EF4444;
      --border: rgba(212,168,67,0.12);
      --glow: rgba(52,211,153,0.15);
    }

    @property --border-angle {
      syntax: '<angle>';
      initial-value: 0deg;
      inherits: false;
    }

    html {
      height: -webkit-fill-available;
    }

    body {
      font-family: 'DM Sans', sans-serif;
      -webkit-user-select: none;
      user-select: none;
      background: var(--bg-primary);
      color: var(--text-primary);
      overflow-x: hidden;
      min-height: 100vh;
      min-height: -webkit-fill-available;
    }

    .safe-top { padding-top: max(env(safe-area-inset-top), 16px); }
    .safe-bottom { padding-bottom: max(env(safe-area-inset-bottom), 24px); }

    /* ---- Buttons ---- */
    .btn-primary {
      background: linear-gradient(135deg, #D4A843, #E0BE6A);
      color: #0B1A0E;
      border: none;
      border-radius: 14px;
      height: 56px;
      width: 100%;
      font-family: 'DM Sans', sans-serif;
      font-weight: 700;
      font-size: 16px;
      cursor: pointer;
      transition: opacity 0.15s ease, transform 0.1s ease, box-shadow 0.15s ease;
    }
    .btn-primary:active { transform: scale(0.98); box-shadow: 0 0 24px rgba(212,168,67,0.5); }
    .btn-primary:disabled { opacity: 0.4; cursor: not-allowed; }

    .btn-primary-light {
      background: var(--cream);
      color: #0B1A0E;
      border: none;
      border-radius: 14px;
      height: 56px;
      width: 100%;
      font-family: 'DM Sans', sans-serif;
      font-weight: 700;
      font-size: 16px;
      cursor: pointer;
      transition: opacity 0.15s ease, transform 0.1s ease;
    }
    .btn-primary-light:active { transform: scale(0.98); opacity: 0.9; }
    .btn-primary-light:disabled { opacity: 0.4; cursor: not-allowed; }

    .btn-success {
      background: linear-gradient(135deg, #34D399, #4AE8AF);
      color: #fff;
      border: none;
      border-radius: 14px;
      height: 56px;
      width: 100%;
      font-family: 'DM Sans', sans-serif;
      font-weight: 700;
      font-size: 16px;
      cursor: pointer;
      transition: opacity 0.15s ease, transform 0.1s ease, box-shadow 0.15s ease;
    }
    .btn-success:active { transform: scale(0.98); box-shadow: 0 0 24px rgba(52,211,153,0.5); }

    .btn-text {
      background: none;
      border: 1px solid transparent;
      border-radius: 8px;
      color: var(--cream);
      font-family: 'DM Sans', sans-serif;
      font-weight: 500;
      font-size: 14px;
      cursor: pointer;
      padding: 8px 16px;
      transition: border-color 0.15s ease;
    }
    .btn-text:hover { border-color: var(--gold); }

    /* ---- Typography ---- */
    .t-hero { font-family: 'Space Mono', monospace; font-size: 80px; font-weight: 700; font-variant-numeric: tabular-nums; line-height: 1; }
    .t-title { font-size: 24px; font-weight: 700; }
    .t-body { font-size: 16px; font-weight: 500; }
    .t-label { font-size: 11px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.1em; color: var(--gold); }
    .t-small { font-size: 14px; font-weight: 400; color: var(--text-secondary); }

    /* ---- Cards ---- */
    .card {
      border-radius: 16px;
      padding: 20px;
      border: 1px solid var(--border);
      background: rgba(26,53,32,0.6);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
    }
    .card-dark {
      border-radius: 16px;
      padding: 20px;
      border: 1px solid var(--border);
      background: rgba(26,53,32,0.6);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
    }

    /* ---- Layout ---- */
    .layout {
      max-width: 400px;
      margin: 0 auto;
      padding: 0 24px;
      width: 100%;
    }

    /* ---- Pulsing dots ---- */
    .pulsing-dots { display: flex; gap: 6px; align-items: center; justify-content: center; }
    .pulsing-dots span {
      width: 8px; height: 8px; border-radius: 50%;
      background: var(--emerald);
      animation: dot-pulse 1.4s ease-in-out infinite;
    }
    .pulsing-dots span:nth-child(2) { animation-delay: 0.2s; }
    .pulsing-dots span:nth-child(3) { animation-delay: 0.4s; }
    @keyframes dot-pulse {
      0%, 80%, 100% { opacity: 0.3; transform: scale(0.8); }
      40% { opacity: 1; transform: scale(1); }
    }

    .pulsing-dots-light span { background: var(--emerald); }

    /* ---- Scan line ---- */
    .scan-line {
      position: absolute;
      left: 0; right: 0; height: 3px;
      background: linear-gradient(90deg, transparent, var(--emerald), transparent);
      box-shadow: 0 0 20px var(--emerald);
      animation: scan-anim 1.8s ease-in-out;
    }
    @keyframes scan-anim {
      0% { top: 0%; opacity: 0; }
      10% { opacity: 1; }
      90% { opacity: 1; }
      100% { top: 100%; opacity: 0; }
    }

    /* ---- Confetti ---- */
    .confetti-particle {
      position: fixed;
      width: 8px; height: 8px;
      border-radius: 2px;
      animation: confetti-fall 2s ease-out forwards;
      z-index: 100;
    }
    @keyframes confetti-fall {
      0% { transform: translateY(0) rotate(0deg); opacity: 1; }
      100% { transform: translateY(100vh) rotate(720deg); opacity: 0; }
    }

    /* ---- Shutter button ---- */
    .shutter-btn {
      width: 72px; height: 72px;
      border-radius: 50%;
      border: 4px solid var(--gold);
      background: transparent;
      display: flex; align-items: center; justify-content: center;
      cursor: pointer;
      transition: transform 0.1s, box-shadow 0.15s;
    }
    .shutter-btn:active { transform: scale(0.92); box-shadow: 0 0 24px rgba(212,168,67,0.5); }
    .shutter-btn-inner {
      width: 56px; height: 56px;
      border-radius: 50%;
      background: var(--cream);
    }

    /* ---- Viewfinder ---- */
    .viewfinder-frame {
      position: relative;
    }
    .viewfinder-corner {
      position: absolute;
      width: 28px;
      height: 28px;
      border-color: var(--gold);
      border-style: solid;
    }
    .vc-tl { top: 0; left: 0; border-width: 3px 0 0 3px; }
    .vc-tr { top: 0; right: 0; border-width: 3px 3px 0 0; }
    .vc-bl { bottom: 0; left: 0; border-width: 0 0 3px 3px; }
    .vc-br { bottom: 0; right: 0; border-width: 0 3px 3px 0; }
    .viewfinder-guide {
      position: absolute;
      left: 0; right: 0;
      top: 50%;
      height: 2px;
      background: linear-gradient(90deg, transparent 10%, var(--emerald) 30%, var(--emerald) 70%, transparent 90%);
      box-shadow: 0 0 10px rgba(52,211,153,0.3);
    }

    /* ---- Video ---- */
    .video-container {
      position: relative;
      border-radius: 16px;
      overflow: hidden;
      background: var(--bg-primary);
      border: 1px solid var(--border);
    }
    .video-container video {
      width: 100%; height: 100%;
      object-fit: cover;
      display: block;
    }

    /* ---- Mute button ---- */
    .mute-btn {
      position: absolute;
      bottom: 12px; left: 12px;
      width: 36px; height: 36px;
      border-radius: 50%;
      border: 1px solid var(--border);
      background: rgba(11,26,14,0.7);
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      display: flex; align-items: center; justify-content: center;
      cursor: pointer;
      z-index: 10;
      color: var(--cream);
      font-size: 16px;
      transition: background 0.15s;
    }
    .mute-btn-active {
      background: rgba(239,68,68,0.3);
      border-color: rgba(239,68,68,0.4);
      color: var(--accent-red);
    }

    /* ---- PIP video ---- */
    .pip-video {
      position: absolute;
      top: 16px; right: 16px;
      width: 100px; height: 100px;
      border-radius: 16px;
      overflow: hidden;
      border: 1px solid var(--border);
      background: var(--bg-primary);
      z-index: 10;
    }
    .pip-video video { width: 100%; height: 100%; object-fit: cover; }

    /* ---- Toast ---- */
    .toast {
      position: fixed;
      top: 0; left: 0; right: 0;
      z-index: 50;
      display: flex; justify-content: center;
      padding: max(env(safe-area-inset-top), 16px) 24px 16px;
    }
    .toast-inner {
      background: rgba(19,42,24,0.85);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      color: var(--cream);
      padding: 14px 24px;
      border-radius: 14px;
      font-size: 14px;
      font-weight: 600;
      border: 1px solid var(--border);
      border-left: 3px solid var(--gold);
      max-width: 400px;
      width: 100%;
      text-align: center;
    }
    .toast-error .toast-inner {
      background: rgba(239,68,68,0.15);
      border-left-color: var(--accent-red);
      color: var(--accent-red);
    }

    /* ---- Timer pulse ---- */
    @keyframes timer-pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.04); }
    }
    .timer-pulse { animation: timer-pulse 0.5s ease-in-out infinite; }

    /* ---- Winner glow ---- */
    .winner-glow {
      box-shadow: 0 0 30px rgba(52, 211, 153, 0.4), 0 0 60px rgba(52, 211, 153, 0.2);
      border: 2px solid var(--emerald) !important;
    }

    /* ---- Instruction pill ---- */
    .instruction-pill {
      background: rgba(19,42,24,0.7);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      color: var(--gold);
      padding: 10px 20px;
      border-radius: 100px;
      font-size: 14px;
      font-weight: 600;
      border: 1px solid var(--border);
    }

    /* ---- Ready badge ---- */
    .ready-badge {
      padding: 6px 14px;
      border-radius: 100px;
      font-size: 12px;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.03em;
    }
    .ready-badge-on {
      background: var(--emerald);
      color: #fff;
      box-shadow: 0 0 12px rgba(52,211,153,0.4);
      animation: ready-glow 1.5s ease-in-out infinite;
    }
    .ready-badge-off {
      background: rgba(26,53,32,0.6);
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      color: var(--text-secondary);
      border: 1px solid var(--border);
    }
    @keyframes ready-glow {
      0%, 100% { box-shadow: 0 0 12px rgba(52,211,153,0.4); }
      50% { box-shadow: 0 0 20px rgba(52,211,153,0.6); }
    }

    /* ---- Pint float animation ---- */
    .pint-float {
      animation: pint-float 3s ease-in-out infinite;
    }
    @keyframes pint-float {
      0%, 100% {
        transform: translateY(0);
        filter: drop-shadow(0 0 15px rgba(212,168,67,0.3));
      }
      50% {
        transform: translateY(-8px);
        filter: drop-shadow(0 0 25px rgba(212,168,67,0.5));
      }
    }

    /* ---- Search ring spinner ---- */
    .search-ring {
      display: inline-block;
      animation: search-spin 1.5s linear infinite;
    }
    @keyframes search-spin {
      to { transform: rotate(360deg); }
    }

    /* ---- Animated gradient border ---- */
    @keyframes rotate-border {
      to { --border-angle: 360deg; }
    }
    .animated-gold-border {
      position: relative;
      border-radius: 16px;
      padding: 20px;
      background: rgba(26,53,32,0.8);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      border: none;
    }
    .animated-gold-border::before {
      content: '';
      position: absolute;
      inset: 0;
      border-radius: inherit;
      border: 2px solid transparent;
      background: conic-gradient(from var(--border-angle, 0deg), #D4A843, #34D399, #D4A843) border-box;
      -webkit-mask: linear-gradient(#fff 0 0) padding-box, linear-gradient(#fff 0 0);
      -webkit-mask-composite: xor;
      mask-composite: exclude;
      animation: rotate-border 3s linear infinite;
      pointer-events: none;
    }

    /* ---- Reduced motion ---- */
    @media (prefers-reduced-motion: reduce) {
      *, *::before, *::after {
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.01ms !important;
      }
      .pint-float { animation: none; }
      .search-ring { animation: none; }
      .pulsing-dots span { animation: none; opacity: 1; }
      .timer-pulse { animation: none; }
      .ready-badge-on { animation: none; }
      .ambient-particle { animation: none; display: none; }
      .confetti-particle { animation: none; display: none; }
      .scan-line { animation: none; }
    }

    /* ---- Ambient particles ---- */
    .ambient-particle {
      position: absolute;
      border-radius: 50%;
      background: rgba(212,168,67,0.3);
      bottom: -10px;
      animation: particle-drift linear infinite;
    }
    @keyframes particle-drift {
      0% { transform: translateY(0) translateX(0); opacity: 0; }
      10% { opacity: 0.5; }
      90% { opacity: 0.5; }
      100% { transform: translateY(-100vh) translateX(20px); opacity: 0; }
    }
  </style>
</head>
<body>
  <div id="splash" style="position:fixed;inset:0;background:#0B1A0E;display:flex;align-items:center;justify-content:center;z-index:99999">
    <div style="text-align:center">
      <div style="font-family:'DM Sans',sans-serif;font-size:28px;font-weight:900;color:#F5E6C8;letter-spacing:0.04em">SPLIT THE G</div>
      <div style="width:48px;height:3px;background:#34D399;border-radius:2px;margin:12px auto 0"></div>
      <div style="margin-top:20px;display:flex;gap:6px;justify-content:center">
        <span class="sp-dot" style="animation-delay:0s"></span>
        <span class="sp-dot" style="animation-delay:0.2s"></span>
        <span class="sp-dot" style="animation-delay:0.4s"></span>
      </div>
    </div>
  </div>
  <style>.sp-dot{width:8px;height:8px;border-radius:50%;background:#34D399;animation:sp 1.4s ease-in-out infinite}@keyframes sp{0%,80%,100%{opacity:.3;transform:scale(.8)}40%{opacity:1;transform:scale(1)}}</style>
  <div id="root"></div>

  <!-- Noise texture overlay -->
  <svg style="position:fixed;inset:0;width:100%;height:100%;pointer-events:none;z-index:1;opacity:0.035">
    <filter id="noiseFilter">
      <feTurbulence type="fractalNoise" baseFrequency="0.8" numOctaves="4" stitchTiles="stitch"/>
    </filter>
    <rect width="100%" height="100%" filter="url(#noiseFilter)"/>
  </svg>

  <script type="text/babel">
    const { useState, useEffect, useRef, useCallback, useMemo, useReducer } = React;
    const { motion, AnimatePresence } = window.Motion;

    // ============ CONFIG ============
    const ICE_SERVERS = {
      iceServers: [
        { urls: 'stun:stun.l.google.com:19302' },
        { urls: 'stun:stun1.l.google.com:19302' }
      ]
    };

    const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
    const springConfig = prefersReducedMotion
      ? { type: "tween", duration: 0 }
      : { type: "spring", stiffness: 300, damping: 30 };

    // ============ UTILITIES ============

    // Haptic feedback
    function haptic(pattern = 50) {
      try { navigator.vibrate && navigator.vibrate(pattern); } catch (e) {}
    }

    // Web Audio API — synthesized sound effects
    let _audioCtx = null;
    function getAudioCtx() {
      if (!_audioCtx) _audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      if (_audioCtx.state === 'suspended') _audioCtx.resume();
      return _audioCtx;
    }
    function playTone(freq, duration, type = 'sine', vol = 0.15) {
      try {
        const ctx = getAudioCtx();
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, ctx.currentTime);
        gain.gain.setValueAtTime(vol, ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + duration);
        osc.connect(gain);
        gain.connect(ctx.destination);
        osc.start();
        osc.stop(ctx.currentTime + duration);
      } catch (e) {}
    }
    const sfx = {
      tick: () => playTone(800, 0.06),
      shutter: () => { playTone(1200, 0.05, 'square', 0.08); playTone(900, 0.08, 'sine', 0.06); },
      go: () => { playTone(523, 0.1); setTimeout(() => playTone(1047, 0.15), 100); },
      win: () => { playTone(784, 0.15); setTimeout(() => playTone(1047, 0.2), 150); },
      lose: () => playTone(300, 0.3, 'sine', 0.1),
    };

    // Compress image for network transmission
    function compressImage(dataUrl, maxWidth = 640, quality = 0.6) {
      return new Promise((resolve) => {
        const img = new Image();
        img.onload = () => {
          const scale = Math.min(1, maxWidth / img.width);
          const canvas = document.createElement('canvas');
          canvas.width = Math.round(img.width * scale);
          canvas.height = Math.round(img.height * scale);
          const ctx = canvas.getContext('2d');
          ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
          resolve(canvas.toDataURL('image/jpeg', quality));
        };
        img.onerror = () => resolve(dataUrl);
        img.src = dataUrl;
      });
    }

    // Accuracy → color
    function getAccuracyColor(acc) {
      if (acc >= 80) return '#34D399';
      if (acc >= 50) return '#D4A843';
      if (acc >= 25) return '#E8943A';
      return '#EF4444';
    }

    // Player rank based on games played and win rate
    function getPlayerRank(gamesPlayed, winRate) {
      if (gamesPlayed < 3) return { name: 'Rookie', color: '#7C9A82', icon: '\u2726' };
      if (gamesPlayed < 5) return winRate >= 60
        ? { name: 'Bronze', color: '#CD7F32', icon: '\u2726' }
        : { name: 'Rookie', color: '#7C9A82', icon: '\u2726' };
      if (gamesPlayed < 10) return winRate >= 65
        ? { name: 'Silver', color: '#C0C0C0', icon: '\u2727' }
        : winRate >= 40
          ? { name: 'Bronze', color: '#CD7F32', icon: '\u2726' }
          : { name: 'Rookie', color: '#7C9A82', icon: '\u2726' };
      if (gamesPlayed < 20) return winRate >= 70
        ? { name: 'Gold', color: '#D4A843', icon: '\u2605' }
        : winRate >= 50
          ? { name: 'Silver', color: '#C0C0C0', icon: '\u2727' }
          : { name: 'Bronze', color: '#CD7F32', icon: '\u2726' };
      if (winRate >= 75) return { name: 'Platinum', color: '#34D399', icon: '\u2605' };
      if (winRate >= 60) return { name: 'Gold', color: '#D4A843', icon: '\u2605' };
      if (winRate >= 45) return { name: 'Silver', color: '#C0C0C0', icon: '\u2727' };
      return { name: 'Bronze', color: '#CD7F32', icon: '\u2726' };
    }

    // ============ CUSTOM HOOKS ============

    function useSocket() {
      const [socket, setSocket] = useState(null);
      const [connected, setConnected] = useState(false);

      useEffect(() => {
        const s = io({
          transports: ['websocket', 'polling'],
          reconnectionDelay: 500,
          reconnectionDelayMax: 3000,
          reconnectionAttempts: 10,
          timeout: 10000
        });
        setSocket(s);
        s.on('connect', () => setConnected(true));
        s.on('disconnect', () => setConnected(false));
        s.on('connect_error', (err) => {
          console.warn('[Socket] connect_error:', err.message);
        });
        s.io.on('reconnect', (attempt) => {
          console.log('[Socket] reconnected after', attempt, 'attempts');
        });
        s.io.on('reconnect_failed', () => {
          console.warn('[Socket] reconnect_failed — all attempts exhausted');
        });
        return () => s.close();
      }, []);

      return { socket, connected };
    }

    function useStats() {
      const defaultStats = { gamesPlayed: 0, wins: 0, losses: 0, ties: 0, currentStreak: 0, bestStreak: 0, bestAccuracy: 0 };

      const [stats, setStats] = useState(() => {
        try {
          const saved = localStorage.getItem('stg-stats');
          if (saved) return { ...defaultStats, ...JSON.parse(saved) };
          // Migrate from old keys
          const migrated = { ...defaultStats };
          const oldStreak = parseInt(localStorage.getItem('stg-streak') || '0', 10);
          if (oldStreak > 0) { migrated.currentStreak = oldStreak; migrated.bestStreak = oldStreak; }
          const legacyHigh = parseInt(localStorage.getItem('split-g-highscore') || '0', 10);
          const legacyGames = parseInt(localStorage.getItem('split-g-games') || '0', 10);
          if (legacyHigh > 0) migrated.bestAccuracy = legacyHigh;
          if (legacyGames > 0) migrated.gamesPlayed = legacyGames;
          localStorage.removeItem('stg-streak');
          localStorage.removeItem('split-g-balance');
          localStorage.removeItem('split-g-highscore');
          localStorage.removeItem('split-g-games');
          if (migrated.gamesPlayed > 0 || migrated.currentStreak > 0) {
            localStorage.setItem('stg-stats', JSON.stringify(migrated));
          }
          return migrated;
        } catch (e) { return defaultStats; }
      });

      const persist = useCallback((s) => {
        try { localStorage.setItem('stg-stats', JSON.stringify(s)); } catch (e) {}
      }, []);

      const recordGame = useCallback(({ outcome, accuracy }) => {
        setStats(prev => {
          const next = { ...prev, gamesPlayed: prev.gamesPlayed + 1 };
          if (outcome === 'win') {
            next.wins = prev.wins + 1;
            next.currentStreak = prev.currentStreak + 1;
            if (next.currentStreak > prev.bestStreak) next.bestStreak = next.currentStreak;
          } else if (outcome === 'loss') {
            next.losses = prev.losses + 1;
            next.currentStreak = 0;
          } else {
            next.ties = prev.ties + 1;
          }
          if (accuracy > prev.bestAccuracy) next.bestAccuracy = accuracy;
          persist(next);
          return next;
        });
      }, [persist]);

      const winRate = useMemo(() => {
        if (stats.gamesPlayed === 0) return 0;
        return Math.round((stats.wins / stats.gamesPlayed) * 100);
      }, [stats.wins, stats.gamesPlayed]);

      return { stats, recordGame, winRate };
    }

    function useNickname() {
      const [nickname, setNickname] = useState(() => {
        try { return localStorage.getItem('stg-nickname') || ''; } catch { return ''; }
      });
      const save = useCallback((name) => {
        const trimmed = name.trim().slice(0, 16);
        setNickname(trimmed);
        try { localStorage.setItem('stg-nickname', trimmed); } catch {}
      }, []);
      return { nickname, setNickname: save };
    }

    function useLeaderboard() {
      const [entries, setEntries] = useState(() => {
        try {
          return JSON.parse(localStorage.getItem('stg-leaderboard') || '[]');
        } catch { return []; }
      });

      const addEntry = useCallback((nickname, accuracy, date) => {
        setEntries(prev => {
          const next = [...prev, { nickname: nickname || 'Anon', accuracy, date: date || Date.now() }]
            .sort((a, b) => b.accuracy - a.accuracy)
            .slice(0, 20);
          try { localStorage.setItem('stg-leaderboard', JSON.stringify(next)); } catch {}
          return next;
        });
      }, []);

      return { entries, addEntry };
    }

    const IS_MOBILE = /Mobi|Android/i.test(navigator.userAgent);

    function useWebRTC(socket, opponentId, isInitiator) {
      const pcRef = useRef(null);
      const localStreamRef = useRef(null);
      const [remoteStream, setRemoteStream] = useState(null);
      const [localStream, setLocalStream] = useState(null);
      const [connectionState, setConnectionState] = useState('new');
      const [error, setError] = useState(null); // null | 'camera' | 'connection'
      const [isMuted, setIsMuted] = useState(false);

      const toggleMute = useCallback(() => {
        if (localStreamRef.current) {
          localStreamRef.current.getAudioTracks().forEach(t => { t.enabled = !t.enabled; });
          setIsMuted(m => !m);
        }
      }, []);

      const cleanup = useCallback(() => {
        if (pcRef.current) { pcRef.current.close(); pcRef.current = null; }
        if (localStreamRef.current) {
          localStreamRef.current.getTracks().forEach(t => t.stop());
          localStreamRef.current = null;
        }
        setLocalStream(null);
        setRemoteStream(null);
        setConnectionState('new');
        setError(null);
        setIsMuted(false);
      }, []);

      // Cleanup on unmount
      useEffect(() => { return () => cleanup(); }, []);

      const start = useCallback(async () => {
        if (!socket || !opponentId) return;
        setError(null);
        try {
          // Fetch ICE config from server (includes TURN if configured)
          let iceConfig = ICE_SERVERS;
          try {
            iceConfig = await new Promise((resolve, reject) => {
              socket.emit('get-ice-config', (config) => {
                if (config && config.iceServers) resolve(config);
                else reject(new Error('No ICE config'));
              });
              setTimeout(() => reject(new Error('ICE config timeout')), 5000);
            });
          } catch (e) {
            // Fall back to hardcoded STUN servers
          }

          const stream = await navigator.mediaDevices.getUserMedia({
            video: {
              facingMode: 'user',
              width: { ideal: IS_MOBILE ? 320 : 640 },
              height: { ideal: IS_MOBILE ? 240 : 480 },
              frameRate: { ideal: IS_MOBILE ? 15 : 24 }
            },
            audio: true
          });
          localStreamRef.current = stream;
          setLocalStream(stream);

          const pc = new RTCPeerConnection(iceConfig);
          pcRef.current = pc;

          stream.getTracks().forEach(track => pc.addTrack(track, stream));

          // Limit video bitrate on mobile
          if (IS_MOBILE) {
            try {
              const videoSender = pc.getSenders().find(s => s.track && s.track.kind === 'video');
              if (videoSender) {
                const params = videoSender.getParameters();
                if (!params.encodings) params.encodings = [{}];
                params.encodings[0].maxBitrate = 250000;
                await videoSender.setParameters(params);
              }
            } catch (e) {}
          }

          pc.ontrack = (e) => {
            if (e.streams && e.streams[0]) {
              setRemoteStream(e.streams[0]);
            }
            if (e.track.kind === 'video') {
              setConnectionState('connected');
            }
          };
          pc.onicecandidate = (e) => {
            if (e.candidate) socket.emit('webrtc-ice-candidate', { candidate: e.candidate });
          };
          pc.onconnectionstatechange = () => {
            setConnectionState(pc.connectionState);
            if (pc.connectionState === 'failed') setError('connection');
          };

          if (isInitiator) {
            const offer = await pc.createOffer();
            await pc.setLocalDescription(offer);
            socket.emit('webrtc-offer', { offer });
          }
        } catch (err) {
          setConnectionState('failed');
          setError('camera');
        }
      }, [socket, opponentId, isInitiator]);

      const retry = useCallback(() => {
        cleanup();
        setTimeout(() => start(), 500);
      }, [cleanup, start]);

      useEffect(() => {
        if (!socket) return;
        const onOffer = async (data) => {
          const pc = pcRef.current;
          if (!pc) return;
          await pc.setRemoteDescription(new RTCSessionDescription(data.offer));
          const answer = await pc.createAnswer();
          await pc.setLocalDescription(answer);
          socket.emit('webrtc-answer', { answer });
        };
        const onAnswer = async (data) => {
          const pc = pcRef.current;
          if (!pc) return;
          await pc.setRemoteDescription(new RTCSessionDescription(data.answer));
        };
        const onIce = async (data) => {
          const pc = pcRef.current;
          if (!pc) return;
          if (!data.candidate) return;
          try {
            await pc.addIceCandidate(new RTCIceCandidate(data.candidate));
          } catch (e) {
            console.warn('[WebRTC] Failed to add ICE candidate:', e.message);
          }
        };
        socket.on('webrtc-offer', onOffer);
        socket.on('webrtc-answer', onAnswer);
        socket.on('webrtc-ice-candidate', onIce);
        return () => {
          socket.off('webrtc-offer', onOffer);
          socket.off('webrtc-answer', onAnswer);
          socket.off('webrtc-ice-candidate', onIce);
        };
      }, [socket]);

      return { localStream, remoteStream, connectionState, error, start, cleanup, retry, isMuted, toggleMute };
    }

    function useCamera(facingMode = 'environment') {
      const streamRef = useRef(null);
      const [stream, setStream] = useState(null);
      const [error, setError] = useState(false);

      const start = useCallback(async () => {
        setError(false);
        try {
          const s = await navigator.mediaDevices.getUserMedia({
            video: { facingMode, width: { ideal: 1920 }, height: { ideal: 1080 } }
          });
          streamRef.current = s;
          setStream(s);
          return s;
        } catch (err) {
          setError(true);
          return null;
        }
      }, [facingMode]);

      const stop = useCallback(() => {
        if (streamRef.current) {
          streamRef.current.getTracks().forEach(t => t.stop());
          streamRef.current = null;
        }
        setStream(null);
      }, []);

      const capture = useCallback((videoEl, canvas) => {
        if (!videoEl || !canvas) return null;
        const ctx = canvas.getContext('2d');
        canvas.width = videoEl.videoWidth || 640;
        canvas.height = videoEl.videoHeight || 480;
        ctx.drawImage(videoEl, 0, 0, canvas.width, canvas.height);
        return canvas.toDataURL('image/jpeg', 0.95);
      }, []);

      useEffect(() => { return () => { stop(); }; }, [stop]);

      return { stream, error, start, stop, capture };
    }

    function usePintAnalysis() {
      const [isAnalyzing, setIsAnalyzing] = useState(false);

      const analyze = useCallback((imageData, canvas) => {
        return new Promise((resolve) => {
          setIsAnalyzing(true);
          const ctx = canvas.getContext('2d');
          const img = new Image();
          img.src = imageData;
          img.onload = () => {
            canvas.width = img.width;
            canvas.height = img.height;
            ctx.drawImage(img, 0, 0);
            const { width, height } = canvas;
            const imageDataObj = ctx.getImageData(0, 0, width, height);
            const pixels = imageDataObj.data;
            const targetY = Math.floor(height / 2);

            // Scan 7 columns across the center third for robustness
            const columns = [];
            for (let c = 0; c < 7; c++) {
              columns.push(Math.floor(width * (0.35 + c * 0.05)));
            }
            const liquidYs = columns.map(cx => {
              for (let y = height - 1; y >= 0; y--) {
                const i = (y * width + cx) * 4;
                const lum = 0.299 * pixels[i] + 0.587 * pixels[i + 1] + 0.114 * pixels[i + 2];
                if (lum > 100) return y;
              }
              return height;
            });
            // Use median for noise resistance
            liquidYs.sort((a, b) => a - b);
            const liquidY = liquidYs[Math.floor(liquidYs.length / 2)];

            const distance = Math.abs(liquidY - targetY);
            const maxDistance = height * 0.15;
            const accuracy = Math.max(0, Math.min(100, 100 - (distance / maxDistance) * 100));
            setIsAnalyzing(false);
            resolve({ liquidY, targetY, accuracy: Math.round(accuracy), height });
          };
          img.onerror = () => {
            setIsAnalyzing(false);
            resolve({ accuracy: 0, liquidY: 0, targetY: 0, height: 0 });
          };
        });
      }, []);

      return { analyze, isAnalyzing };
    }

    // ============ SHARED COMPONENTS ============

    function PulsingDots({ light }) {
      return (
        <div className={`pulsing-dots ${light ? 'pulsing-dots-light' : ''}`}>
          <span /><span /><span />
        </div>
      );
    }

    function SearchRing() {
      return (
        <div className="search-ring">
          <svg width="64" height="64" viewBox="0 0 64 64">
            <circle cx="32" cy="32" r="26" fill="none" stroke="rgba(52,211,153,0.15)" strokeWidth="3" />
            <circle cx="32" cy="32" r="26" fill="none" stroke="#34D399" strokeWidth="3"
              strokeDasharray="50 114" strokeLinecap="round" />
            <circle cx="32" cy="32" r="26" fill="none" stroke="#D4A843" strokeWidth="3"
              strokeDasharray="15 149" strokeLinecap="round" strokeDashoffset="-50" />
          </svg>
        </div>
      );
    }

    function TimerArc({ progress }) {
      const radius = 58;
      const circumference = 2 * Math.PI * radius;
      const offset = circumference * (1 - progress);
      const color = progress > 0.33 ? '#34D399' : progress > 0.17 ? '#D4A843' : '#EF4444';

      return (
        <svg width="160" height="160" viewBox="0 0 128 128"
          style={{ position: 'absolute', top: '50%', left: '50%', transform: 'translate(-50%, -50%) rotate(-90deg)' }}>
          <circle cx="64" cy="64" r={radius} fill="none" stroke="rgba(52,211,153,0.08)" strokeWidth="2.5" />
          <circle cx="64" cy="64" r={radius} fill="none"
            stroke={color}
            strokeWidth="2.5"
            strokeDasharray={circumference} strokeDashoffset={offset}
            strokeLinecap="round"
            style={{ transition: 'stroke-dashoffset 0.1s linear, stroke 1s ease' }} />
        </svg>
      );
    }

    function AmbientParticles() {
      return (
        <div style={{ position: 'absolute', inset: 0, overflow: 'hidden', pointerEvents: 'none' }}>
          {[0,1,2,3,4,5].map(i => (
            <div key={i} className="ambient-particle" style={{
              left: `${10 + i * 16}%`,
              width: 3 + (i % 3),
              height: 3 + (i % 3),
              animationDelay: `${i * 1.2}s`,
              animationDuration: `${6 + i * 1.5}s`,
            }} />
          ))}
        </div>
      );
    }

    function Toast({ message, type = 'info', visible }) {
      return (
        <AnimatePresence>
          {visible && (
            <motion.div
              initial={{ y: -60, opacity: 0 }}
              animate={{ y: 0, opacity: 1 }}
              exit={{ y: -60, opacity: 0 }}
              transition={springConfig}
              className={`toast ${type === 'error' ? 'toast-error' : ''}`}
            >
              <div className="toast-inner">{message}</div>
            </motion.div>
          )}
        </AnimatePresence>
      );
    }

    function ConnectionBanner({ connected }) {
      return (
        <AnimatePresence>
          {!connected && (
            <motion.div
              initial={{ y: -60, opacity: 0 }}
              animate={{ y: 0, opacity: 1 }}
              exit={{ y: -60, opacity: 0 }}
              transition={springConfig}
              style={{
                position: 'fixed',
                top: 0, left: 0, right: 0,
                zIndex: 45,
                display: 'flex', justifyContent: 'center',
                padding: 'max(env(safe-area-inset-top), 16px) 24px 12px',
              }}>
              <div style={{
                background: 'rgba(239,68,68,0.15)',
                backdropFilter: 'blur(20px)',
                WebkitBackdropFilter: 'blur(20px)',
                color: 'var(--accent-red)',
                padding: '12px 24px',
                borderRadius: 14,
                fontSize: 14,
                fontWeight: 600,
                border: '1px solid rgba(239,68,68,0.25)',
                maxWidth: 400,
                width: '100%',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                gap: 10,
              }}>
                Reconnecting...
                <PulsingDots />
              </div>
            </motion.div>
          )}
        </AnimatePresence>
      );
    }

    function VideoFeed({ stream, muted = false, mirrored = false, style, className = '' }) {
      const ref = useRef(null);
      useEffect(() => {
        if (ref.current && stream) ref.current.srcObject = stream;
      }, [stream]);
      return (
        <video
          ref={ref}
          autoPlay playsInline muted={muted}
          style={{ transform: mirrored ? 'scaleX(-1)' : 'none', ...style }}
          className={className}
        />
      );
    }

    function MuteButton({ isMuted, onToggle }) {
      return (
        <button className={`mute-btn ${isMuted ? 'mute-btn-active' : ''}`} onClick={onToggle} aria-label={isMuted ? 'Unmute' : 'Mute'}>
          {isMuted ? (
            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round">
              <line x1="1" y1="1" x2="23" y2="23"/><path d="M9 9v3a3 3 0 0 0 5.12 2.12M15 9.34V4a3 3 0 0 0-5.94-.6"/><path d="M17 16.95A7 7 0 0 1 5 12v-2m14 0v2c0 .76-.12 1.49-.34 2.18"/><line x1="12" y1="19" x2="12" y2="23"/><line x1="8" y1="23" x2="16" y2="23"/>
            </svg>
          ) : (
            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round">
              <path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/><line x1="12" y1="19" x2="12" y2="23"/><line x1="8" y1="23" x2="16" y2="23"/>
            </svg>
          )}
        </button>
      );
    }

    function ShutterButton({ onClick, disabled }) {
      return (
        <button className="shutter-btn" onClick={onClick} disabled={disabled}>
          <div className="shutter-btn-inner" />
        </button>
      );
    }

    function ConfettiBurst() {
      const particles = useMemo(() =>
        Array.from({ length: 20 }, (_, i) => ({
          id: i,
          left: 30 + Math.random() * 40,
          delay: Math.random() * 0.4,
          color: ['#34D399', '#D4A843', '#F5E6C8', '#34D399'][i % 4],
          rotation: Math.random() * 360,
        })), []);
      return (
        <div style={{ position: 'fixed', inset: 0, pointerEvents: 'none', zIndex: 100 }}>
          {particles.map(p => (
            <div key={p.id} className="confetti-particle" style={{
              left: `${p.left}%`, top: '-10px', background: p.color,
              animationDelay: `${p.delay}s`, transform: `rotate(${p.rotation}deg)`
            }} />
          ))}
        </div>
      );
    }

    function RollingNumber({ value, duration = 1000 }) {
      const [display, setDisplay] = useState(0);
      useEffect(() => {
        if (value === null || value === undefined) return;
        const startTime = performance.now();
        let rafId;
        const tick = (now) => {
          const elapsed = now - startTime;
          const progress = Math.min(elapsed / duration, 1);
          setDisplay(Math.floor(progress * value));
          if (progress < 1) {
            rafId = requestAnimationFrame(tick);
          } else {
            setDisplay(value);
          }
        };
        rafId = requestAnimationFrame(tick);
        return () => cancelAnimationFrame(rafId);
      }, [value, duration]);
      return <span style={{ fontFamily: "'Space Mono', monospace", fontVariantNumeric: 'tabular-nums' }}>{display}</span>;
    }

    function PintIcon() {
      return (
        <div className="pint-float">
          <svg width="64" height="88" viewBox="0 0 120 160" style={{ display: 'block', margin: '0 auto' }}>
            <path d="M30 20 L25 130 Q25 142 35 142 L85 142 Q95 142 95 130 L90 20 Q90 15 82 15 L38 15 Q30 15 30 20 Z"
              fill="none" stroke="#D4A843" strokeWidth="2.5" strokeLinecap="round"/>
            <path d="M31 90 L26 130 Q26 140 35 140 L85 140 Q94 140 94 130 L89 90 Z" fill="#1C0F00"/>
            <ellipse cx="60" cy="90" rx="32" ry="10" fill="#F5E6C8" opacity="0.95"/>
            <ellipse cx="60" cy="17" rx="22" ry="5" stroke="#D4A843" strokeWidth="1.5" fill="none"/>
          </svg>
        </div>
      );
    }

    function StatCard({ label, value, color }) {
      return (
        <div className="card-dark" style={{ padding: 12, textAlign: 'center' }}>
          <p className="t-label" style={{ marginBottom: 4, fontSize: 10 }}>{label}</p>
          <div style={{ fontSize: 22, fontWeight: 700, fontFamily: "'Space Mono', monospace", fontVariantNumeric: 'tabular-nums', color: color || 'var(--cream)' }}>
            {value}
          </div>
        </div>
      );
    }

    function LeaderboardCard({ entries }) {
      if (!entries.length) return null;
      const medals = ['\uD83E\uDD47', '\uD83E\uDD48', '\uD83E\uDD49'];
      return (
        <div className="card-dark" style={{ marginTop: 16, padding: 16 }}>
          <p className="t-label" style={{ marginBottom: 12, textAlign: 'center' }}>BEST SPLITS</p>
          {entries.slice(0, 5).map((e, i) => (
            <div key={i} style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', padding: '6px 0', borderBottom: i < Math.min(entries.length, 5) - 1 ? '1px solid var(--border)' : 'none' }}>
              <span style={{ fontSize: 14, color: 'var(--cream)', fontWeight: 600 }}>
                {i < 3 ? medals[i] : `${i + 1}.`} {e.nickname}
              </span>
              <span style={{ fontSize: 14, fontWeight: 700, fontFamily: "'Space Mono', monospace", color: getAccuracyColor(e.accuracy) }}>
                {e.accuracy}%
              </span>
            </div>
          ))}
        </div>
      );
    }

    function SeriesScoreBar({ myScore, opScore, round, opponentName }) {
      return (
        <div style={{ display: 'flex', justifyContent: 'center', alignItems: 'center', gap: 16, padding: '8px 0' }}>
          <div style={{ textAlign: 'center' }}>
            <div style={{ fontSize: 11, color: 'var(--text-secondary)' }}>YOU</div>
            <div style={{ fontSize: 24, fontWeight: 700, fontFamily: "'Space Mono', monospace", color: 'var(--emerald)' }}>{myScore}</div>
          </div>
          <div style={{ fontSize: 12, color: 'var(--gold)', fontWeight: 700 }}>ROUND {round}</div>
          <div style={{ textAlign: 'center' }}>
            <div style={{ fontSize: 11, color: 'var(--text-secondary)' }}>{opponentName || 'OPP'}</div>
            <div style={{ fontSize: 24, fontWeight: 700, fontFamily: "'Space Mono', monospace", color: 'var(--accent-red)' }}>{opScore}</div>
          </div>
        </div>
      );
    }

    function LandscapeWarning() {
      const [isLandscape, setIsLandscape] = useState(false);
      useEffect(() => {
        const check = () => setIsLandscape(window.innerHeight < 500 && window.innerWidth > window.innerHeight);
        check();
        window.addEventListener('resize', check);
        window.addEventListener('orientationchange', check);
        return () => { window.removeEventListener('resize', check); window.removeEventListener('orientationchange', check); };
      }, []);
      if (!isLandscape) return null;
      return (
        <div style={{ position: 'fixed', inset: 0, zIndex: 9999, background: 'var(--bg-primary)', display: 'flex', alignItems: 'center', justifyContent: 'center', flexDirection: 'column', gap: 16 }}>
          <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="var(--gold)" strokeWidth="1.5" strokeLinecap="round" strokeLinejoin="round">
            <rect x="4" y="2" width="16" height="20" rx="2"/>
            <path d="M12 18h.01"/>
          </svg>
          <p style={{ color: 'var(--cream)', fontSize: 18, fontWeight: 700 }}>Please rotate your device</p>
          <p style={{ color: 'var(--text-secondary)', fontSize: 14 }}>Split the G works best in portrait mode</p>
        </div>
      );
    }

    // ============ SCREEN COMPONENTS ============

    function LandingScreen({ onStart, onQuickPlay, stats, winRate, nickname, onSetNickname, leaderboardEntries, seriesMode, onSetSeriesMode }) {
      const rank = getPlayerRank(stats.gamesPlayed, winRate);
      const hasPlayed = stats.gamesPlayed > 0;

      return (
        <motion.div
          key="landing"
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
          exit={{ opacity: 0, y: -20 }}
          transition={springConfig}
          style={{ minHeight: '100vh', background: 'var(--bg-primary)', display: 'flex', flexDirection: 'column', position: 'relative', overflow: 'hidden' }}
          className="safe-top safe-bottom"
        >
          <AmbientParticles />
          <div className="layout" style={{ flex: 1, display: 'flex', flexDirection: 'column', justifyContent: 'center', alignItems: 'center', gap: 12, position: 'relative', zIndex: 1 }}>
            <div style={{ textAlign: 'center', marginBottom: 24 }}>
              <PintIcon />
            </div>
            <h1 style={{ fontSize: 32, fontWeight: 900, letterSpacing: '0.04em', color: 'var(--cream)', textAlign: 'center' }}>
              SPLIT THE G
            </h1>
            <div style={{ width: 48, height: 3, background: 'var(--emerald)', borderRadius: 2, margin: '4px auto 0' }} />
            <p style={{ textAlign: 'center', color: 'var(--gold)', fontSize: 14, fontWeight: 600, letterSpacing: '0.05em', marginTop: 8 }}>The Guinness Challenge</p>

            {hasPlayed && (
              <div style={{
                display: 'inline-flex', alignItems: 'center', gap: 6,
                padding: '6px 16px', borderRadius: 100,
                background: rank.color + '15',
                border: '1px solid ' + rank.color + '33',
                color: rank.color, fontSize: 13, fontWeight: 700,
                fontFamily: "'Space Mono', monospace", marginTop: 8
              }}>
                {rank.icon} {rank.name}
              </div>
            )}

            {hasPlayed && (
              <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: 10, width: '100%', marginTop: 16 }}>
                <StatCard label="PLAYED" value={stats.gamesPlayed} />
                <StatCard label="WIN RATE" value={winRate + '%'} color={winRate >= 50 ? 'var(--emerald)' : 'var(--text-secondary)'} />
                <StatCard label="STREAK" value={stats.currentStreak} color={stats.currentStreak > 0 ? 'var(--emerald)' : 'var(--text-secondary)'} />
                <StatCard label="BEST ACC" value={stats.bestAccuracy + '%'} color={getAccuracyColor(stats.bestAccuracy)} />
              </div>
            )}

            {hasPlayed && (
              <div style={{ display: 'flex', justifyContent: 'center', gap: 16, fontSize: 12, color: 'var(--text-secondary)', marginTop: 8 }}>
                <span>Best Streak: {stats.bestStreak}</span>
                <span>{stats.wins}W - {stats.losses}L - {stats.ties}T</span>
              </div>
            )}

            <div className="card-dark" style={{ padding: '12px 16px', display: 'flex', alignItems: 'center', gap: 10, width: '100%', marginTop: 16 }}>
              <span style={{ fontSize: 12, fontWeight: 700, color: 'var(--gold)', whiteSpace: 'nowrap' }}>NAME</span>
              <input
                type="text"
                value={nickname}
                onChange={(e) => onSetNickname(e.target.value)}
                placeholder="Enter nickname"
                maxLength={16}
                style={{
                  flex: 1, background: 'transparent', border: 'none', outline: 'none',
                  color: 'var(--cream)', fontSize: 16, fontWeight: 600,
                  fontFamily: "'DM Sans', sans-serif"
                }}
              />
            </div>

            {leaderboardEntries && leaderboardEntries.length > 0 && (
              <LeaderboardCard entries={leaderboardEntries} />
            )}

            <div style={{ display: 'flex', gap: 8, width: '100%', marginTop: 12 }}>
              <button
                className={seriesMode === 'single' ? 'btn-primary' : 'btn-text'}
                style={{ flex: 1, height: 44, border: seriesMode !== 'single' ? '1px solid var(--border)' : 'none' }}
                onClick={() => onSetSeriesMode('single')}>
                Single
              </button>
              <button
                className={seriesMode === 'best-of-3' ? 'btn-primary' : 'btn-text'}
                style={{ flex: 1, height: 44, border: seriesMode !== 'best-of-3' ? '1px solid var(--border)' : 'none' }}
                onClick={() => onSetSeriesMode('best-of-3')}>
                Best of 3
              </button>
            </div>

            <div style={{ height: hasPlayed ? 16 : 32 }} />
            <button className="btn-primary" onClick={onStart}>Get Started</button>
            {hasPlayed && (
              <button className="btn-text" style={{ color: 'var(--emerald)', marginTop: 8, fontSize: 14, fontWeight: 600 }} onClick={onQuickPlay}>
                Quick Play — Skip Photo
              </button>
            )}
          </div>
        </motion.div>
      );
    }

    function CaptureScreen({ mode, onCapture, onCancel, capturedImage, isScanning, analysisResult, remoteStream }) {
      const videoRef = useRef(null);
      const camera = useCamera('environment');
      const [ready, setReady] = useState(false);
      const [showFlash, setShowFlash] = useState(false);

      useEffect(() => {
        camera.start();
        return () => camera.stop();
      }, []);

      useEffect(() => {
        if (videoRef.current && camera.stream) {
          videoRef.current.srcObject = camera.stream;
          videoRef.current.onloadedmetadata = () => setReady(true);
        }
      }, [camera.stream]);

      const instruction = mode === 'full-pint' ? 'Photograph your full pint' : 'Show your result';

      const handleShutter = useCallback(() => {
        setShowFlash(true);
        haptic(40);
        sfx.shutter();
        setTimeout(() => setShowFlash(false), 150);
        const canvas = document.createElement('canvas');
        const img = camera.capture(videoRef.current, canvas);
        if (img) onCapture(img);
      }, [camera, onCapture]);

      if (capturedImage) {
        return (
          <motion.div key="capture-result-view" initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0 }}
            transition={springConfig}
            style={{ minHeight: '100vh', background: '#000', position: 'relative' }}>
            <img src={capturedImage} alt="Captured" style={{ width: '100%', height: '100vh', objectFit: 'cover' }} />
            {isScanning && <div className="scan-line" />}
            <div style={{ position: 'absolute', top: 0, left: 0, right: 0 }} className="safe-top">
              <div style={{ display: 'flex', justifyContent: 'center', padding: 16 }}>
                <div className="instruction-pill">Analyzing...</div>
              </div>
            </div>
          </motion.div>
        );
      }

      return (
        <motion.div
          key="capture"
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          exit={{ opacity: 0 }}
          transition={springConfig}
          style={{ minHeight: '100vh', background: '#000', position: 'relative' }}
        >
          {/* Camera flash overlay */}
          {showFlash && <div style={{ position: 'absolute', inset: 0, background: 'rgba(255,255,255,0.75)', zIndex: 20, pointerEvents: 'none' }} />}

          {camera.error ? (
            <div style={{ position: 'absolute', inset: 0, display: 'flex', alignItems: 'center', justifyContent: 'center', background: 'var(--bg-primary)', color: 'var(--cream)', padding: 24, textAlign: 'center' }}>
              <div style={{ display: 'flex', flexDirection: 'column', alignItems: 'center', gap: 16, maxWidth: 300 }}>
                <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="var(--accent-red)" strokeWidth="1.5" strokeLinecap="round" strokeLinejoin="round">
                  <path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"/>
                  <circle cx="12" cy="13" r="4"/>
                  <line x1="2" y1="2" x2="22" y2="22"/>
                </svg>
                <p className="t-title" style={{ color: 'var(--cream)', marginBottom: 4 }}>Camera Access Required</p>
                <p className="t-small" style={{ lineHeight: 1.5 }}>
                  Split the G needs your camera to photograph your pint.
                  Please allow camera access in your browser settings.
                </p>
                <div style={{ fontSize: 12, color: 'var(--text-secondary)', background: 'var(--bg-elevated)', padding: '10px 14px', borderRadius: 10, lineHeight: 1.6, textAlign: 'left', width: '100%' }}>
                  <strong style={{ color: 'var(--cream)' }}>iOS:</strong> Settings &gt; Safari &gt; Camera &gt; Allow<br/>
                  <strong style={{ color: 'var(--cream)' }}>Android:</strong> Tap the lock icon in the address bar
                </div>
                <button className="btn-primary" style={{ width: 200 }} onClick={() => camera.start()}>Try Again</button>
                {onCancel && <button className="btn-text" style={{ color: 'var(--text-secondary)' }} onClick={onCancel}>Go Back</button>}
              </div>
            </div>
          ) : (
            <>
              <video ref={videoRef} autoPlay playsInline muted style={{ position: 'absolute', inset: 0, width: '100%', height: '100%', objectFit: 'cover' }} />

              {/* Opponent PIP during result capture */}
              {remoteStream && (
                <div className="pip-video" style={{ top: 80 }}>
                  <VideoFeed stream={remoteStream} mirrored />
                </div>
              )}

              {/* Instruction pill */}
              <div style={{ position: 'absolute', top: 0, left: 0, right: 0, zIndex: 5 }} className="safe-top">
                <div style={{ display: 'flex', justifyContent: 'center', padding: 16 }}>
                  <div className="instruction-pill">{instruction}</div>
                </div>
              </div>

              {/* Viewfinder with gold corner brackets */}
              <div style={{ position: 'absolute', inset: 0, display: 'flex', alignItems: 'center', justifyContent: 'center', padding: 48 }}>
                <div className="viewfinder-frame" style={{ width: '100%', maxWidth: 280, aspectRatio: '3/4' }}>
                  <div className="viewfinder-corner vc-tl" />
                  <div className="viewfinder-corner vc-tr" />
                  <div className="viewfinder-corner vc-bl" />
                  <div className="viewfinder-corner vc-br" />
                  <div className="viewfinder-guide" />
                </div>
              </div>

              {/* Bottom controls */}
              <div style={{ position: 'absolute', bottom: 0, left: 0, right: 0, zIndex: 5 }} className="safe-bottom">
                <div style={{ display: 'flex', flexDirection: 'column', alignItems: 'center', gap: 16, padding: '0 24px 16px' }}>
                  <ShutterButton onClick={handleShutter} disabled={!ready} />
                  {onCancel && <button className="btn-text" style={{ color: 'var(--text-secondary)' }} onClick={onCancel}>Cancel</button>}
                </div>
              </div>
            </>
          )}
        </motion.div>
      );
    }

    function SearchingScreen({ onCancel, onSolo, pintThumbnail }) {
      const [countdown, setCountdown] = useState(30);
      const [timedOut, setTimedOut] = useState(false);

      useEffect(() => {
        const interval = setInterval(() => {
          setCountdown(c => {
            if (c <= 1) {
              clearInterval(interval);
              setTimedOut(true);
              return 0;
            }
            return c - 1;
          });
        }, 1000);
        return () => clearInterval(interval);
      }, []);

      // Auto-trigger solo mode on timeout
      useEffect(() => {
        if (timedOut) onSolo();
      }, [timedOut, onSolo]);

      return (
        <motion.div
          key="searching"
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          exit={{ opacity: 0 }}
          transition={springConfig}
          style={{ minHeight: '100vh', background: 'var(--bg-primary)', display: 'flex', flexDirection: 'column', alignItems: 'center', justifyContent: 'center' }}
        >
          <div className="layout" style={{ textAlign: 'center' }}>
            {pintThumbnail && (
              <div style={{ marginBottom: 32 }}>
                <img src={pintThumbnail} alt="Your pint" style={{ width: 48, height: 48, borderRadius: 12, objectFit: 'cover', border: '1px solid rgba(212,168,67,0.3)', boxShadow: '0 0 8px rgba(212,168,67,0.15)' }} />
              </div>
            )}
            <div style={{ marginBottom: 24 }}>
              <SearchRing />
            </div>
            <p style={{ fontSize: 20, fontWeight: 600, color: 'var(--gold)', marginBottom: 8 }}>Looking for an opponent</p>
            <p className="t-small" style={{ marginBottom: 8 }}>
              {countdown > 0 ? 'This won\'t take long' : 'Starting solo mode...'}
            </p>
            <p style={{ fontSize: 13, fontWeight: 600, fontFamily: "'Space Mono', monospace", color: 'var(--text-secondary)', marginBottom: 24 }}>
              {countdown > 0 && `Solo mode in ${countdown}s`}
            </p>
            <div style={{ display: 'flex', flexDirection: 'column', gap: 12, alignItems: 'center' }}>
              <button className="btn-text" style={{ color: 'var(--emerald)' }} onClick={onSolo}>Play Solo Now</button>
              <button className="btn-text" onClick={onCancel}>Cancel</button>
            </div>
          </div>
        </motion.div>
      );
    }

    function MatchedScreen({ localStream, remoteStream, onReady, connectionState, webrtcError, onRetryWebRTC, isMuted, onToggleMute, opponentPintImage }) {
      const [toastVisible, setToastVisible] = useState(true);
      const [timedOut, setTimedOut] = useState(false);
      const [autoRetries, setAutoRetries] = useState(0);

      useEffect(() => {
        const t = setTimeout(() => setToastVisible(false), 3000);
        return () => clearTimeout(t);
      }, []);

      // 15s timeout for remote stream
      useEffect(() => {
        if (remoteStream) { setTimedOut(false); return; }
        const t = setTimeout(() => setTimedOut(true), 15000);
        return () => clearTimeout(t);
      }, [remoteStream]);

      const hasFailed = webrtcError || connectionState === 'failed' || timedOut;
      const errorMessage = webrtcError === 'camera'
        ? 'Camera access was denied. Please allow camera permissions.'
        : webrtcError === 'connection'
          ? 'Video connection failed.'
          : timedOut
            ? 'Connection timed out.'
            : null;

      // Auto-retry up to 3 times
      useEffect(() => {
        if (hasFailed && autoRetries < 3 && webrtcError !== 'camera') {
          const t = setTimeout(() => {
            setAutoRetries(c => c + 1);
            setTimedOut(false);
            onRetryWebRTC();
          }, 2000 + autoRetries * 1000);
          return () => clearTimeout(t);
        }
      }, [hasFailed, autoRetries, webrtcError]);

      const connectionPhase = useMemo(() => {
        if (webrtcError === 'camera') return 'camera-error';
        if (hasFailed && autoRetries >= 3) return 'failed';
        if (hasFailed && autoRetries < 3) return 'retrying';
        if (remoteStream) return 'connected';
        if (connectionState === 'connecting') return 'connecting';
        return 'starting';
      }, [webrtcError, hasFailed, autoRetries, remoteStream, connectionState]);

      const statusMessage = {
        'starting': 'Initializing connection...',
        'connecting': 'Establishing peer connection...',
        'retrying': `Retrying... (${autoRetries + 1}/3)`,
        'connected': null,
        'camera-error': errorMessage,
        'failed': errorMessage,
      }[connectionPhase];

      return (
        <motion.div
          key="matched"
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          exit={{ opacity: 0 }}
          transition={springConfig}
          style={{ minHeight: '100vh', background: 'var(--bg-primary)', display: 'flex', flexDirection: 'column' }}
          className="safe-top safe-bottom"
        >
          <Toast message="Matched! Connecting video..." visible={toastVisible} />
          <div style={{ flex: 1, display: 'grid', gridTemplateRows: '1fr 1fr', gap: 8, padding: '8px 8px 0' }}>
            <div className="video-container" style={{ position: 'relative' }}>
              {remoteStream ? <VideoFeed stream={remoteStream} mirrored /> : (
                <div style={{ width: '100%', height: '100%', display: 'flex', flexDirection: 'column', alignItems: 'center', justifyContent: 'center', color: 'var(--text-secondary)', minHeight: 200, gap: 12, padding: 24, textAlign: 'center' }}>
                  {connectionPhase === 'failed' || connectionPhase === 'camera-error' ? (
                    <>
                      <p style={{ color: 'var(--accent-red)', fontSize: 14, fontWeight: 600 }}>{statusMessage}</p>
                      <button className="btn-text" style={{ color: 'var(--emerald)' }} onClick={() => { setAutoRetries(0); setTimedOut(false); onRetryWebRTC(); }}>Retry Connection</button>
                      {connectionPhase === 'failed' && (
                        <button className="btn-text" style={{ color: 'var(--text-secondary)', fontSize: 12 }} onClick={onReady}>Continue Without Video</button>
                      )}
                    </>
                  ) : (
                    <>
                      <PulsingDots light />
                      <p style={{ fontSize: 13, color: 'var(--text-secondary)' }}>{statusMessage}</p>
                    </>
                  )}
                </div>
              )}
              {opponentPintImage && (
                <img src={opponentPintImage} alt="Opponent's pint"
                  style={{ position: 'absolute', bottom: 8, right: 8, width: 48, height: 64, objectFit: 'cover', borderRadius: 8, border: '2px solid rgba(255,255,255,0.2)', boxShadow: '0 2px 8px rgba(0,0,0,0.4)' }} />
              )}
            </div>
            <div className="video-container" style={{ position: 'relative' }}>
              {localStream ? <VideoFeed stream={localStream} muted mirrored /> : (
                <div style={{ width: '100%', height: '100%', display: 'flex', flexDirection: 'column', alignItems: 'center', justifyContent: 'center', color: 'var(--text-secondary)', minHeight: 200, gap: 12 }}>
                  <PulsingDots light />
                  <p style={{ fontSize: 13, color: 'var(--text-secondary)' }}>Starting camera...</p>
                </div>
              )}
              {localStream && <MuteButton isMuted={isMuted} onToggle={onToggleMute} />}
            </div>
          </div>
          <div style={{ padding: '16px 24px' }}>
            <button className="btn-primary-light" onClick={onReady} disabled={!localStream}>
              {localStream ? 'Continue' : 'Starting camera...'}
            </button>
          </div>
        </motion.div>
      );
    }

    function ReadyScreen({ localStream, remoteStream, myReady, opponentReady, onReady, isMuted, onToggleMute }) {
      return (
        <motion.div
          key="ready"
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          exit={{ opacity: 0 }}
          transition={springConfig}
          style={{ minHeight: '100vh', background: 'var(--bg-primary)', display: 'flex', flexDirection: 'column' }}
          className="safe-top safe-bottom"
        >
          <div style={{ flex: 1, display: 'grid', gridTemplateRows: '1fr 1fr', gap: 8, padding: '8px 8px 0' }}>
            <div className="video-container" style={{ position: 'relative' }}>
              {remoteStream ? <VideoFeed stream={remoteStream} mirrored /> : (
                <div style={{ width: '100%', height: '100%', display: 'flex', alignItems: 'center', justifyContent: 'center', minHeight: 200 }}>
                  <PulsingDots light />
                </div>
              )}
              <div style={{ position: 'absolute', top: 12, right: 12 }}>
                <div className={`ready-badge ${opponentReady ? 'ready-badge-on' : 'ready-badge-off'}`}>
                  {opponentReady ? 'READY' : '...'}
                </div>
              </div>
            </div>
            <div className="video-container" style={{ position: 'relative' }}>
              {localStream ? <VideoFeed stream={localStream} muted mirrored /> : (
                <div style={{ width: '100%', height: '100%', display: 'flex', alignItems: 'center', justifyContent: 'center', minHeight: 200 }}>
                  <PulsingDots light />
                </div>
              )}
              <div style={{ position: 'absolute', top: 12, right: 12 }}>
                <div className={`ready-badge ${myReady ? 'ready-badge-on' : 'ready-badge-off'}`}>
                  {myReady ? 'READY' : '...'}
                </div>
              </div>
              {localStream && <MuteButton isMuted={isMuted} onToggle={onToggleMute} />}
            </div>
          </div>
          <div style={{ padding: '16px 24px' }}>
            {!myReady ? (
              <button className="btn-success" onClick={() => { haptic(30); onReady(); }}>Ready Up</button>
            ) : (
              <button className="btn-primary-light" disabled>Waiting for opponent...</button>
            )}
          </div>
        </motion.div>
      );
    }

    function CountdownScreen({ gameStartTime, remoteStream, onDone, soloMode, soloFallback, isMuted, onToggleMute }) {
      const [phase, setPhase] = useState('pre'); // 'pre' | 'timer'
      const [preNum, setPreNum] = useState(3);
      const [timer, setTimer] = useState(30);
      const [showGo, setShowGo] = useState(false);
      const [flash, setFlash] = useState(false);
      const rafRef = useRef(null);
      const timerStartRef = useRef(null);

      const goPhrase = useMemo(() => ['Slainte!', 'GO!', 'Slainte!', 'GO!'][Math.floor(Math.random() * 4)], []);

      // Haptic + sound on countdown number change
      useEffect(() => {
        if (phase === 'pre' && !showGo) {
          sfx.tick();
          haptic(30);
        }
      }, [preNum]);

      useEffect(() => {
        // Pre-countdown: 3, 2, 1, GO!
        const delay = gameStartTime ? Math.max(0, gameStartTime - Date.now()) : 0;

        const t3 = setTimeout(() => setPreNum(3), 0);
        const t2 = setTimeout(() => setPreNum(2), delay > 2000 ? delay / 3 : 1000);
        const t1 = setTimeout(() => setPreNum(1), delay > 2000 ? (delay / 3) * 2 : 2000);
        const tGo = setTimeout(() => {
          setShowGo(true);
          setFlash(true);
          sfx.go();
          haptic([50, 30, 100]);
          setTimeout(() => setFlash(false), 200);
        }, delay > 2000 ? delay - 200 : 2800);

        const tStart = setTimeout(() => {
          setPhase('timer');
          timerStartRef.current = performance.now();
          const tick = (now) => {
            const elapsed = (now - timerStartRef.current) / 1000;
            const remaining = Math.max(0, +(30 - elapsed).toFixed(1));
            setTimer(remaining);
            if (remaining > 0) {
              rafRef.current = requestAnimationFrame(tick);
            }
          };
          rafRef.current = requestAnimationFrame(tick);
        }, Math.max(delay, 3000));

        return () => {
          clearTimeout(t3); clearTimeout(t2); clearTimeout(t1); clearTimeout(tGo); clearTimeout(tStart);
          if (rafRef.current) cancelAnimationFrame(rafRef.current);
        };
      }, [gameStartTime]);

      // Haptic + sound at timer thresholds
      const timerInt = Math.floor(timer);
      useEffect(() => {
        if (phase !== 'timer' || timer >= 30) return;
        if (timerInt === 10) {
          haptic(30);
          sfx.tick();
        } else if (timerInt <= 5 && timerInt > 0) {
          haptic(20);
          sfx.tick();
        }
      }, [timerInt, phase]);

      // Auto-transition when timer hits 0
      useEffect(() => {
        if (timer === 0 && phase === 'timer') onDone();
      }, [timer, phase, onDone]);

      if (phase === 'pre') {
        return (
          <motion.div key="countdown-pre"
            initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0 }}
            transition={springConfig}
            style={{ minHeight: '100vh', background: 'var(--bg-primary)', display: 'flex', alignItems: 'center', justifyContent: 'center', position: 'relative' }}>
            {flash && <div style={{ position: 'absolute', inset: 0, background: 'rgba(52,211,153,0.25)', zIndex: 20 }} />}
            <AnimatePresence mode="wait">
              {!showGo ? (
                <motion.div key={preNum}
                  initial={{ scale: 0, opacity: 0 }}
                  animate={{ scale: 1, opacity: 1 }}
                  exit={{ scale: 2, opacity: 0 }}
                  transition={{ duration: 0.4 }}
                  style={{ fontSize: 120, fontWeight: 700, fontFamily: "'Space Mono', monospace", color: 'var(--cream)' }}>
                  {preNum}
                </motion.div>
              ) : (
                <motion.div key="go"
                  initial={{ scale: 0, opacity: 0 }}
                  animate={{ scale: 1, opacity: 1 }}
                  exit={{ scale: 2, opacity: 0 }}
                  transition={{ duration: 0.3 }}
                  style={{ fontSize: 100, fontWeight: 900, color: 'var(--emerald)' }}>
                  {goPhrase}
                </motion.div>
              )}
            </AnimatePresence>
          </motion.div>
        );
      }

      const isLow = timer <= 10;
      const isCritical = timer <= 5;

      return (
        <motion.div key="countdown-timer"
          initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0 }}
          transition={springConfig}
          style={{ minHeight: '100vh', background: 'var(--bg-primary)', display: 'flex', flexDirection: 'column', position: 'relative' }}
          className="safe-top safe-bottom">

          {/* Opponent left badge */}
          {soloFallback && (
            <div style={{ position: 'absolute', top: 16, left: 16, zIndex: 15, padding: '6px 12px', borderRadius: 100, background: 'rgba(239,68,68,0.15)', border: '1px solid rgba(239,68,68,0.25)', color: 'var(--accent-red)', fontSize: 11, fontWeight: 700 }}>
              OPPONENT LEFT
            </div>
          )}

          {/* PIP opponent (hidden in solo mode) */}
          {!soloMode && !soloFallback && (
            <div className="pip-video">
              {remoteStream ? <VideoFeed stream={remoteStream} mirrored /> : (
                <div style={{ width: '100%', height: '100%', display: 'flex', alignItems: 'center', justifyContent: 'center' }}>
                  <PulsingDots light />
                </div>
              )}
              {onToggleMute && <MuteButton isMuted={isMuted} onToggle={onToggleMute} />}
            </div>
          )}

          <div style={{ flex: 1, display: 'flex', flexDirection: 'column', alignItems: 'center', justifyContent: 'center' }}>
            <p className="t-label" style={{ marginBottom: 16 }}>TIME REMAINING</p>
            <div style={{ position: 'relative', display: 'flex', alignItems: 'center', justifyContent: 'center' }}>
              <TimerArc progress={timer / 30} />
              <div className={`t-hero ${isLow ? 'timer-pulse' : ''}`} style={{ color: isCritical ? 'var(--accent-red)' : 'var(--cream)', position: 'relative' }}>
                {timer.toFixed(1)}
              </div>
            </div>
            <p style={{ fontSize: 16, fontWeight: 500, color: 'var(--text-secondary)', marginTop: 12 }}>
              Stop exactly at the G
            </p>
          </div>

          <div className="layout" style={{ paddingBottom: 16 }}>
            <button className="btn-success" onClick={() => {
              if (rafRef.current) cancelAnimationFrame(rafRef.current);
              haptic(50);
              onDone();
            }}>I'm Done</button>
          </div>
        </motion.div>
      );
    }

    function WaitingScreen({ accuracy, resultImage, remoteStream, opponentSubmitted, timeoutEnd }) {
      const [countdown, setCountdown] = useState(() => {
        if (timeoutEnd) return Math.max(0, Math.ceil((timeoutEnd - Date.now()) / 1000));
        return 90;
      });

      useEffect(() => {
        if (opponentSubmitted) return;
        const interval = setInterval(() => {
          if (timeoutEnd) {
            const remaining = Math.max(0, Math.ceil((timeoutEnd - Date.now()) / 1000));
            setCountdown(remaining);
            if (remaining <= 0) clearInterval(interval);
          } else {
            setCountdown(c => {
              if (c <= 1) { clearInterval(interval); return 0; }
              return c - 1;
            });
          }
        }, 1000);
        return () => clearInterval(interval);
      }, [opponentSubmitted, timeoutEnd]);

      const progress = countdown / 90;
      const ringRadius = 22;
      const ringCircumference = 2 * Math.PI * ringRadius;
      const ringOffset = ringCircumference * (1 - progress);

      return (
        <motion.div key="waiting"
          initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0 }}
          transition={springConfig}
          style={{ minHeight: '100vh', background: 'var(--bg-primary)', display: 'flex', flexDirection: 'column', alignItems: 'center', justifyContent: 'center', position: 'relative' }}
          className="safe-top safe-bottom">

          <div className="pip-video">
            {remoteStream ? <VideoFeed stream={remoteStream} mirrored /> : null}
          </div>

          <div className="layout" style={{ textAlign: 'center' }}>
            <p className="t-label" style={{ marginBottom: 12 }}>YOUR ACCURACY</p>
            <div style={{ fontSize: 64, fontWeight: 700, fontFamily: "'Space Mono', monospace", color: accuracy !== null ? getAccuracyColor(accuracy) : 'var(--cream)', fontVariantNumeric: 'tabular-nums', marginBottom: 16 }}>
              {accuracy !== null ? <><RollingNumber value={accuracy} />%</> : '--'}
            </div>

            {resultImage && (
              <div style={{ marginBottom: 24 }}>
                <img src={resultImage} alt="Your result"
                  style={{ width: 120, height: 120, borderRadius: 16, objectFit: 'cover', border: '1px solid rgba(212,168,67,0.3)', boxShadow: '0 0 8px rgba(212,168,67,0.15)', margin: '0 auto', display: 'block' }} />
              </div>
            )}

            {opponentSubmitted ? (
              <>
                <div style={{ marginBottom: 8 }}>
                  <PulsingDots light />
                </div>
                <p style={{ fontSize: 14, fontWeight: 500, color: 'var(--emerald)' }}>
                  Opponent submitted! Preparing results...
                </p>
              </>
            ) : (
              <>
                <div style={{ position: 'relative', display: 'inline-flex', alignItems: 'center', justifyContent: 'center', marginBottom: 12 }}>
                  <svg width="56" height="56" viewBox="0 0 56 56" style={{ transform: 'rotate(-90deg)' }}>
                    <circle cx="28" cy="28" r={ringRadius} fill="none" stroke="rgba(52,211,153,0.1)" strokeWidth="3" />
                    <circle cx="28" cy="28" r={ringRadius} fill="none"
                      stroke={countdown > 20 ? 'var(--emerald)' : countdown > 10 ? 'var(--gold)' : 'var(--accent-red)'}
                      strokeWidth="3"
                      strokeDasharray={ringCircumference} strokeDashoffset={ringOffset}
                      strokeLinecap="round"
                      style={{ transition: 'stroke-dashoffset 1s linear, stroke 1s ease' }} />
                  </svg>
                  <span style={{
                    position: 'absolute',
                    fontSize: 14, fontWeight: 700,
                    fontFamily: "'Space Mono', monospace",
                    color: countdown > 20 ? 'var(--text-secondary)' : countdown > 10 ? 'var(--gold)' : 'var(--accent-red)',
                  }}>{countdown}</span>
                </div>
                {countdown > 0 ? (
                  <p style={{ fontSize: 14, fontWeight: 500, color: 'var(--text-secondary)' }}>
                    Waiting for opponent... ({countdown}s)
                  </p>
                ) : (
                  <div style={{ marginTop: 4 }}>
                    <p style={{ fontSize: 16, fontWeight: 700, color: 'var(--emerald)' }}>Opponent timed out &mdash; you win!</p>
                    <div style={{ marginTop: 8 }}><PulsingDots light /></div>
                    <p style={{ fontSize: 12, color: 'var(--text-secondary)', marginTop: 4 }}>Waiting for server confirmation...</p>
                  </div>
                )}
              </>
            )}
          </div>
        </motion.div>
      );
    }

    function RevealScreen({ revealData, playerId, onRematch, onNewOpponent, onCancelRematch, onNextRound, rematchRequested, rematchPending, onAcceptRematch, onDeclineRematch, stats, winRate, isRematch, seriesData }) {
      const [phase, setPhase] = useState(0);
      const [showConfetti, setShowConfetti] = useState(false);

      const { results, winnerId, player1Id, player2Id, opponentName: revealOpName } = revealData;
      const isWinner = winnerId === playerId;
      const isTie = winnerId === null;
      const opId = playerId === player1Id ? player2Id : player1Id;
      const myResult = results[playerId];
      const opResult = results[opId];
      const rank = getPlayerRank(stats.gamesPlayed, winRate);
      const opLabel = revealOpName || 'OPPONENT';

      useEffect(() => {
        const full = [0, 1000, 2500, 4000, 5500, 7000, 8500];
        const fast = [0, 400, 1000, 1600, 2200, 2800, 3400];
        const timings = isRematch ? fast : full;
        const timers = timings.map((delay, i) => setTimeout(() => setPhase(i), delay));
        const confettiDelay = isRematch ? 3200 : 7500;
        const confettiTimer = setTimeout(() => {
          if (winnerId === playerId) {
            setShowConfetti(true);
            setTimeout(() => setShowConfetti(false), 2500);
          }
        }, confettiDelay);
        return () => { timers.forEach(clearTimeout); clearTimeout(confettiTimer); };
      }, [winnerId, playerId, isRematch]);

      // Sound + haptic on winner reveal
      useEffect(() => {
        if (phase === 5) {
          haptic([100, 50, 100]);
          if (isWinner) sfx.win();
          else if (!isTie) sfx.lose();
        }
      }, [phase]);

      const handleShare = useCallback(async () => {
        const text = isWinner
          ? `I won Split the G with ${myResult.accuracy}% accuracy! (${rank.name} rank)`
          : `I scored ${myResult.accuracy}% on Split the G! (${rank.name} rank)`;
        try { await navigator.share({ title: 'Split the G', text }); } catch (e) {}
      }, [isWinner, myResult, rank]);

      return (
        <motion.div key="reveal"
          initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0 }}
          transition={springConfig}
          style={{ minHeight: '100vh', background: 'var(--bg-primary)', display: 'flex', flexDirection: 'column', position: 'relative' }}
          className="safe-top safe-bottom">

          {showConfetti && <ConfettiBurst />}

          {/* Emerald pulse glow on winner announce */}
          {phase >= 5 && isWinner && (
            <motion.div
              initial={{ opacity: 0 }}
              animate={{ opacity: [0, 0.8, 0, 0.5, 0] }}
              transition={{ duration: 2, ease: "easeInOut" }}
              style={{
                position: 'fixed', inset: 0,
                background: 'radial-gradient(circle at center, rgba(52,211,153,0.12) 0%, transparent 70%)',
                pointerEvents: 'none', zIndex: 0
              }}
            />
          )}

          <div className="layout" style={{ flex: 1, display: 'flex', flexDirection: 'column', justifyContent: 'center', gap: 16, position: 'relative', zIndex: 1 }}>

            {/* Phase 0: Title */}
            {phase >= 0 && (
              <motion.div
                initial={{ opacity: 0, y: 10 }}
                animate={{ opacity: phase === 0 ? 1 : 0.4, y: 0 }}
                transition={springConfig}
                style={{ textAlign: 'center', marginBottom: 8 }}>
                <p style={{ fontSize: 16, fontWeight: 600, color: 'var(--text-secondary)' }}>The Results Are In</p>
              </motion.div>
            )}

            {/* Phase 1-2: Opponent card */}
            {phase >= 1 && (
              <motion.div
                initial={{ opacity: 0, y: 40 }}
                animate={{ opacity: 1, y: 0 }}
                transition={springConfig}
                className={phase >= 5 && !isTie && !isWinner ? 'animated-gold-border' : 'card-dark'}>
                <p className="t-label" style={{ marginBottom: 8 }}>{opLabel}</p>
                {opResult.image && (
                  <div style={{ marginBottom: 12 }}>
                    <img src={opResult.image} alt="Opponent"
                      style={{ width: '100%', height: 100, objectFit: 'cover', borderRadius: 12 }} />
                  </div>
                )}
                <div style={{ textAlign: 'center' }}>
                  {phase >= 2 ? (
                    <motion.div initial={{ scale: 0 }} animate={{ scale: 1 }}
                      transition={springConfig}
                      style={{ fontSize: 36, fontWeight: 700, fontFamily: "'Space Mono', monospace", color: getAccuracyColor(opResult.accuracy) }}>
                      <RollingNumber value={opResult.accuracy} />%
                    </motion.div>
                  ) : (
                    <div style={{ fontSize: 36, fontWeight: 700, fontFamily: "'Space Mono', monospace", color: 'var(--text-secondary)' }}>---</div>
                  )}
                </div>
              </motion.div>
            )}

            {/* Phase 3-4: My card */}
            {phase >= 3 && (
              <motion.div
                initial={{ opacity: 0, y: 40 }}
                animate={{ opacity: 1, y: 0 }}
                transition={springConfig}
                className={phase >= 5 && !isTie && isWinner ? 'animated-gold-border' : 'card-dark'}>
                <p className="t-label" style={{ marginBottom: 8 }}>YOU</p>
                {myResult.image && (
                  <div style={{ marginBottom: 12 }}>
                    <img src={myResult.image} alt="You"
                      style={{ width: '100%', height: 100, objectFit: 'cover', borderRadius: 12 }} />
                  </div>
                )}
                <div style={{ textAlign: 'center' }}>
                  {phase >= 4 ? (
                    <motion.div initial={{ scale: 0 }} animate={{ scale: 1 }}
                      transition={springConfig}
                      style={{ fontSize: 36, fontWeight: 700, fontFamily: "'Space Mono', monospace", color: getAccuracyColor(myResult.accuracy) }}>
                      <RollingNumber value={myResult.accuracy} />%
                    </motion.div>
                  ) : (
                    <div style={{ fontSize: 36, fontWeight: 700, fontFamily: "'Space Mono', monospace", color: 'var(--text-secondary)' }}>---</div>
                  )}
                </div>
              </motion.div>
            )}

            {/* Phase 5: Winner announcement */}
            {phase >= 5 && (
              <motion.div
                initial={{ scale: 0 }}
                animate={{ scale: [0, 1.1, 1] }}
                transition={{ duration: 0.5 }}
                style={{ textAlign: 'center', padding: '16px 0' }}>
                {seriesData && seriesData.seriesOver ? (
                  <>
                    <div style={{
                      fontSize: 28, fontWeight: 900,
                      color: seriesData.seriesWinner === playerId ? 'var(--emerald)' : 'var(--accent-red)',
                      marginBottom: 4
                    }}>
                      {seriesData.seriesWinner === playerId ? 'SERIES WIN!' : 'SERIES LOST'}
                    </div>
                    <p style={{ fontSize: 14, fontWeight: 400, color: 'var(--text-secondary)' }}>
                      {seriesData.seriesWinner === playerId ? 'You took the best of 3!' : 'They took the best of 3'}
                    </p>
                  </>
                ) : (
                  <>
                    <div style={{
                      fontSize: 28, fontWeight: 900,
                      color: isTie ? 'var(--text-secondary)' : isWinner ? 'var(--emerald)' : 'var(--accent-red)',
                      marginBottom: 4
                    }}>
                      {isTie ? "It's a Tie" : isWinner ? 'You Win' : 'You Lose'}
                    </div>
                    <p style={{ fontSize: 14, fontWeight: 400, color: 'var(--text-secondary)' }}>
                      {seriesData ? `Round ${seriesData.round} of 3` : (isTie ? 'Perfectly matched!' : isWinner ? 'Superior split!' : 'Better luck next time')}
                    </p>
                  </>
                )}
              </motion.div>
            )}

            {/* Series score bar */}
            {phase >= 5 && seriesData && (
              <motion.div initial={{ opacity: 0, y: 10 }} animate={{ opacity: 1, y: 0 }} transition={springConfig}>
                <SeriesScoreBar
                  myScore={seriesData.score[playerId] || 0}
                  opScore={seriesData.score[opId] || 0}
                  round={seriesData.round}
                  opponentName={opLabel} />
              </motion.div>
            )}

            {/* Phase 6: Stats update card */}
            {phase >= 6 && (
              <motion.div initial={{ opacity: 0, y: 20 }} animate={{ opacity: 1, y: 0 }}
                transition={springConfig}
                className="card-dark" style={{ padding: 16 }}>
                <p className="t-label" style={{ marginBottom: 12, textAlign: 'center' }}>YOUR RECORD</p>
                <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr 1fr', gap: 8, textAlign: 'center' }}>
                  <div>
                    <div style={{ fontSize: 11, color: 'var(--text-secondary)', marginBottom: 2 }}>W-L-T</div>
                    <div style={{ fontSize: 16, fontWeight: 700, fontFamily: "'Space Mono', monospace", color: 'var(--cream)' }}>
                      {stats.wins}-{stats.losses}-{stats.ties}
                    </div>
                  </div>
                  <div>
                    <div style={{ fontSize: 11, color: 'var(--text-secondary)', marginBottom: 2 }}>WIN RATE</div>
                    <div style={{ fontSize: 16, fontWeight: 700, fontFamily: "'Space Mono', monospace", color: winRate >= 50 ? 'var(--emerald)' : 'var(--text-secondary)' }}>
                      {winRate}%
                    </div>
                  </div>
                  <div>
                    <div style={{ fontSize: 11, color: 'var(--text-secondary)', marginBottom: 2 }}>STREAK</div>
                    <div style={{ fontSize: 16, fontWeight: 700, fontFamily: "'Space Mono', monospace", color: stats.currentStreak > 0 ? 'var(--emerald)' : 'var(--text-secondary)' }}>
                      {stats.currentStreak}
                    </div>
                  </div>
                </div>
                {myResult.accuracy >= stats.bestAccuracy && myResult.accuracy > 0 && (
                  <div style={{ marginTop: 12, textAlign: 'center', padding: '6px 12px', background: 'rgba(212,168,67,0.1)', borderRadius: 8, color: 'var(--gold)', fontSize: 12, fontWeight: 700 }}>
                    NEW PERSONAL BEST: {myResult.accuracy}%
                  </div>
                )}
                {stats.currentStreak > 1 && stats.currentStreak === stats.bestStreak && isWinner && (
                  <div style={{ marginTop: 8, textAlign: 'center', padding: '6px 12px', background: 'rgba(52,211,153,0.1)', borderRadius: 8, color: 'var(--emerald)', fontSize: 12, fontWeight: 700 }}>
                    NEW BEST STREAK: {stats.bestStreak}
                  </div>
                )}
                <div style={{ textAlign: 'center', marginTop: 8, fontSize: 12, color: rank.color, fontWeight: 600 }}>
                  {rank.icon} {rank.name} Rank
                </div>
              </motion.div>
            )}

            {/* Post-game actions */}
            {phase >= 6 && (
              <motion.div initial={{ opacity: 0, y: 20 }} animate={{ opacity: 1, y: 0 }}
                transition={springConfig}
                style={{ display: 'flex', flexDirection: 'column', gap: 12, marginTop: 8 }}>

                {seriesData && !seriesData.seriesOver ? (
                  /* Best-of-3 series in progress — show Next Round */
                  <>
                    <button className="btn-success" onClick={onNextRound}
                      style={{ fontSize: 16, fontWeight: 700, padding: '14px 0' }}>
                      Next Round
                    </button>
                    <button className="btn-text" style={{ color: 'var(--text-secondary)', textAlign: 'center' }} onClick={onNewOpponent}>
                      Forfeit Series
                    </button>
                  </>
                ) : rematchPending ? (
                  <div className="card-dark" style={{ textAlign: 'center' }}>
                    <p style={{ color: 'var(--text-primary)', fontWeight: 600, marginBottom: 12 }}>Opponent wants a rematch!</p>
                    <div style={{ display: 'flex', gap: 12 }}>
                      <button className="btn-success" style={{ flex: 1 }} onClick={onAcceptRematch}>Accept</button>
                      <button className="btn-primary-light" style={{ flex: 1 }} onClick={onDeclineRematch}>Decline</button>
                    </div>
                  </div>
                ) : (
                  <>
                    {rematchRequested ? (
                      <div className="card-dark" style={{ textAlign: 'center', padding: 16 }}>
                        <PulsingDots light />
                        <p style={{ fontSize: 14, fontWeight: 600, color: 'var(--gold)', marginTop: 8 }}>Rematch requested</p>
                        <p style={{ fontSize: 12, color: 'var(--text-secondary)', marginTop: 4 }}>Waiting for opponent to respond...</p>
                        <button className="btn-text" style={{ color: 'var(--text-secondary)', marginTop: 12 }}
                          onClick={onCancelRematch}>
                          Cancel
                        </button>
                      </div>
                    ) : (
                      <button className="btn-primary-light" onClick={onRematch}>Rematch</button>
                    )}
                    <button className="btn-text" style={{ color: 'var(--text-secondary)', textAlign: 'center' }} onClick={onNewOpponent}>
                      New Opponent
                    </button>
                    {typeof navigator.share === 'function' && (
                      <button className="btn-text" style={{ color: 'var(--gold)', textAlign: 'center' }} onClick={handleShare}>
                        Share Result
                      </button>
                    )}
                  </>
                )}
              </motion.div>
            )}
          </div>
        </motion.div>
      );
    }

    function SoloRevealScreen({ accuracy, resultImage, onPlayAgain, onHome, stats, winRate }) {
      const [phase, setPhase] = useState(0);
      const [showConfetti, setShowConfetti] = useState(false);
      const rank = getPlayerRank(stats.gamesPlayed, winRate);
      const isGood = accuracy >= 50;

      useEffect(() => {
        const timings = [0, 1500, 3000, 4500];
        const timers = timings.map((delay, i) => setTimeout(() => setPhase(i), delay));
        if (accuracy >= 80) {
          const confettiTimer = setTimeout(() => {
            setShowConfetti(true);
            setTimeout(() => setShowConfetti(false), 2500);
          }, 3500);
          timers.push(confettiTimer);
        }
        return () => timers.forEach(clearTimeout);
      }, [accuracy]);

      useEffect(() => {
        if (phase === 2) {
          haptic([100, 50, 100]);
          if (isGood) sfx.win(); else sfx.lose();
        }
      }, [phase]);

      const handleShare = useCallback(async () => {
        const text = `I scored ${accuracy}% on Split the G! (${rank.name} rank)`;
        try { await navigator.share({ title: 'Split the G', text }); } catch (e) {}
      }, [accuracy, rank]);

      const tierLabel = accuracy >= 97 ? 'GUINNESS GOD' : accuracy >= 80 ? 'Excellent' : accuracy >= 50 ? 'Decent Split' : accuracy >= 25 ? 'Needs Work' : 'Shocking';
      const tierColor = getAccuracyColor(accuracy);

      return (
        <motion.div key="solo-reveal"
          initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0 }}
          transition={springConfig}
          style={{ minHeight: '100vh', background: 'var(--bg-primary)', display: 'flex', flexDirection: 'column', position: 'relative' }}
          className="safe-top safe-bottom">

          {showConfetti && <ConfettiBurst />}

          {phase >= 2 && isGood && (
            <motion.div initial={{ opacity: 0 }} animate={{ opacity: [0, 0.8, 0, 0.5, 0] }}
              transition={{ duration: 2, ease: "easeInOut" }}
              style={{ position: 'fixed', inset: 0, background: 'radial-gradient(circle at center, rgba(52,211,153,0.12) 0%, transparent 70%)', pointerEvents: 'none', zIndex: 0 }} />
          )}

          <div className="layout" style={{ flex: 1, display: 'flex', flexDirection: 'column', justifyContent: 'center', gap: 16, position: 'relative', zIndex: 1 }}>

            {phase >= 0 && (
              <motion.div initial={{ opacity: 0, y: 10 }} animate={{ opacity: 1, y: 0 }} transition={springConfig}
                style={{ textAlign: 'center', marginBottom: 8 }}>
                <p style={{ fontSize: 14, fontWeight: 600, color: 'var(--text-secondary)', letterSpacing: '0.05em' }}>SOLO CHALLENGE</p>
              </motion.div>
            )}

            {phase >= 1 && (
              <motion.div initial={{ opacity: 0, y: 40 }} animate={{ opacity: 1, y: 0 }} transition={springConfig}
                className="card-dark">
                {resultImage && (
                  <div style={{ marginBottom: 12 }}>
                    <img src={resultImage} alt="Your result" style={{ width: '100%', height: 120, objectFit: 'cover', borderRadius: 12 }} />
                  </div>
                )}
                <div style={{ textAlign: 'center' }}>
                  <p className="t-label" style={{ marginBottom: 8 }}>YOUR ACCURACY</p>
                  <motion.div initial={{ scale: 0 }} animate={{ scale: 1 }} transition={springConfig}
                    style={{ fontSize: 48, fontWeight: 700, fontFamily: "'Space Mono', monospace", color: tierColor }}>
                    <RollingNumber value={accuracy} />%
                  </motion.div>
                </div>
              </motion.div>
            )}

            {phase >= 2 && (
              <motion.div initial={{ scale: 0 }} animate={{ scale: [0, 1.1, 1] }} transition={{ duration: 0.5 }}
                style={{ textAlign: 'center', padding: '12px 0' }}>
                <div style={{ fontSize: 24, fontWeight: 900, color: tierColor, marginBottom: 4 }}>
                  {tierLabel}
                </div>
              </motion.div>
            )}

            {phase >= 3 && (
              <motion.div initial={{ opacity: 0, y: 20 }} animate={{ opacity: 1, y: 0 }} transition={springConfig}
                className="card-dark" style={{ padding: 16 }}>
                <p className="t-label" style={{ marginBottom: 12, textAlign: 'center' }}>YOUR RECORD</p>
                <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr 1fr', gap: 8, textAlign: 'center' }}>
                  <div>
                    <div style={{ fontSize: 11, color: 'var(--text-secondary)', marginBottom: 2 }}>W-L-T</div>
                    <div style={{ fontSize: 16, fontWeight: 700, fontFamily: "'Space Mono', monospace", color: 'var(--cream)' }}>
                      {stats.wins}-{stats.losses}-{stats.ties}
                    </div>
                  </div>
                  <div>
                    <div style={{ fontSize: 11, color: 'var(--text-secondary)', marginBottom: 2 }}>WIN RATE</div>
                    <div style={{ fontSize: 16, fontWeight: 700, fontFamily: "'Space Mono', monospace", color: winRate >= 50 ? 'var(--emerald)' : 'var(--text-secondary)' }}>
                      {winRate}%
                    </div>
                  </div>
                  <div>
                    <div style={{ fontSize: 11, color: 'var(--text-secondary)', marginBottom: 2 }}>BEST ACC</div>
                    <div style={{ fontSize: 16, fontWeight: 700, fontFamily: "'Space Mono', monospace", color: getAccuracyColor(stats.bestAccuracy) }}>
                      {stats.bestAccuracy}%
                    </div>
                  </div>
                </div>
                {accuracy >= stats.bestAccuracy && accuracy > 0 && (
                  <div style={{ marginTop: 12, textAlign: 'center', padding: '6px 12px', background: 'rgba(212,168,67,0.1)', borderRadius: 8, color: 'var(--gold)', fontSize: 12, fontWeight: 700 }}>
                    NEW PERSONAL BEST: {accuracy}%
                  </div>
                )}
                <div style={{ textAlign: 'center', marginTop: 8, fontSize: 12, color: rank.color, fontWeight: 600 }}>
                  {rank.icon} {rank.name} Rank
                </div>
              </motion.div>
            )}

            {phase >= 3 && (
              <motion.div initial={{ opacity: 0, y: 20 }} animate={{ opacity: 1, y: 0 }} transition={springConfig}
                style={{ display: 'flex', flexDirection: 'column', gap: 12, marginTop: 8 }}>
                <button className="btn-primary" onClick={onPlayAgain}>Play Again</button>
                <button className="btn-text" style={{ color: 'var(--text-secondary)', textAlign: 'center' }} onClick={onHome}>Home</button>
                {typeof navigator.share === 'function' && (
                  <button className="btn-text" style={{ color: 'var(--gold)', textAlign: 'center' }} onClick={handleShare}>Share Result</button>
                )}
              </motion.div>
            )}
          </div>
        </motion.div>
      );
    }

    // ============ MAIN APP ============

    const initialGameState = {
      screen: 'landing',
      roomId: null,
      playerId: null,
      opponentId: null,
      opponentName: null,
      isInitiator: false,
      myReady: false,
      opponentReady: false,
      gameStartTime: null,
      pintImage: null,
      opponentPintImage: null,
      myResult: null,
      opponentSubmitted: false,
      revealData: null,
      capturedResultImage: null,
      isScanning: false,
      soloMode: false,
      soloFallback: false,
      timeoutEnd: null,
      rematchRequested: false,
      rematchPending: false,
      isRematch: false,
      seriesMode: 'single',
      seriesData: null,
    };

    function gameReducer(state, action) {
      switch (action.type) {
        case 'SET_SCREEN':
          return { ...state, screen: action.screen };
        case 'MATCHED':
          return { ...state, roomId: action.roomId, playerId: action.playerId, opponentId: action.opponentId, opponentName: action.opponentName || null, isInitiator: action.isInitiator, opponentPintImage: action.opponentPintImage || null, seriesMode: action.mode || 'single', screen: 'matched' };
        case 'UPDATE_PLAYER_ID':
          return { ...state, playerId: action.playerId };
        case 'SET_SERIES_MODE':
          return { ...state, seriesMode: action.mode };
        case 'READY_UPDATE':
          return { ...state, myReady: action.myReady !== undefined ? action.myReady : state.myReady, opponentReady: action.opponentReady !== undefined ? action.opponentReady : state.opponentReady };
        case 'SET_MY_READY':
          return { ...state, myReady: true };
        case 'GAME_START':
          return { ...state, gameStartTime: action.countdownStart, screen: 'countdown' };
        case 'OPPONENT_SUBMITTED':
          return { ...state, opponentSubmitted: true, timeoutEnd: action.timeoutEnd || state.timeoutEnd };
        case 'SET_TIMEOUT_END':
          return { ...state, timeoutEnd: action.timeoutEnd };
        case 'REVEAL_START':
          return { ...state, revealData: action.data, seriesData: action.data.series || null, screen: 'reveal' };
        case 'NEXT_ROUND':
          return { ...state, myReady: false, opponentReady: false, myResult: null, opponentSubmitted: false, revealData: null, capturedResultImage: null, isScanning: false, pintImage: null, timeoutEnd: null, isRematch: true, screen: 'countdown', gameStartTime: action.countdownStart };
        case 'SET_SOLO_MODE':
          return { ...state, soloMode: true, gameStartTime: action.gameStartTime, screen: 'countdown' };
        case 'SET_MY_RESULT':
          return { ...state, myResult: action.result };
        case 'SET_PINT_IMAGE':
          return { ...state, pintImage: action.image };
        case 'SET_CAPTURED_RESULT':
          return { ...state, capturedResultImage: action.image, isScanning: action.isScanning !== undefined ? action.isScanning : state.isScanning };
        case 'SET_SCANNING':
          return { ...state, isScanning: action.isScanning };
        case 'SET_REMATCH_STATE':
          return { ...state, rematchRequested: action.requested !== undefined ? action.requested : state.rematchRequested, rematchPending: action.pending !== undefined ? action.pending : state.rematchPending };
        case 'REMATCH_ACCEPTED':
          return { ...state, myReady: false, opponentReady: false, myResult: null, opponentSubmitted: false, revealData: null, rematchRequested: false, rematchPending: false, capturedResultImage: null, isScanning: false, pintImage: null, timeoutEnd: null, isRematch: true, soloFallback: false, screen: 'capture-pint' };
        case 'LEAVE_ROOM':
          return { ...initialGameState };
        case 'SOLO_HOME':
          return { ...state, soloMode: false, myResult: null, capturedResultImage: null, isScanning: false, pintImage: null, timeoutEnd: null, screen: 'landing' };
        case 'SOLO_PLAY_AGAIN':
          return { ...state, myResult: null, capturedResultImage: null, isScanning: false, gameStartTime: action.gameStartTime, screen: 'countdown' };
        case 'SET_SOLO_CONTINUE':
          return { ...state, soloMode: true, soloFallback: true };
        default:
          return state;
      }
    }

    function App() {
      const { socket, connected } = useSocket();
      const { stats, recordGame, winRate } = useStats();
      const { nickname, setNickname } = useNickname();
      const leaderboard = useLeaderboard();
      const [preferredMode, setPreferredMode] = useState('single');

      const [g, dispatch] = useReducer(gameReducer, initialGameState);

      // Toast (kept separate — high-frequency, UI-only)
      const [toastMsg, setToastMsg] = useState(null);
      const [toastType, setToastType] = useState('info');
      const [toastVisible, setToastVisible] = useState(false);

      const canvasRef = useRef(null);
      const screenRef = useRef(g.screen);
      const myResultRef = useRef(g.myResult);
      const soloModeRef = useRef(g.soloMode);
      const { analyze } = usePintAnalysis();

      // Keep refs in sync
      useEffect(() => { screenRef.current = g.screen; }, [g.screen]);
      useEffect(() => { myResultRef.current = g.myResult; }, [g.myResult]);
      useEffect(() => { soloModeRef.current = g.soloMode; }, [g.soloMode]);

      // WebRTC
      const webrtc = useWebRTC(socket, g.opponentId, g.isInitiator);

      const showToast = useCallback((msg, type = 'info') => {
        setToastMsg(msg);
        setToastType(type);
        setToastVisible(true);
        setTimeout(() => setToastVisible(false), 3000);
      }, []);

      // Track stats on reveal
      useEffect(() => {
        if (g.revealData && g.playerId) {
          const myRes = g.revealData.results[g.playerId];
          const accuracy = myRes ? myRes.accuracy : 0;
          if (g.revealData.winnerId === g.playerId) recordGame({ outcome: 'win', accuracy });
          else if (g.revealData.winnerId === null) recordGame({ outcome: 'tie', accuracy });
          else recordGame({ outcome: 'loss', accuracy });
          leaderboard.addEntry(nickname || 'Anon', accuracy);
        }
      }, [g.revealData, g.playerId, recordGame]);

      // Auto-rejoin room on socket reconnect
      useEffect(() => {
        if (!socket) return;
        const onReconnect = () => {
          if (g.roomId && g.playerId) {
            socket.emit('rejoin-room', { roomId: g.roomId, oldSocketId: g.playerId });
            dispatch({ type: 'UPDATE_PLAYER_ID', playerId: socket.id });
          }
        };
        socket.io.on('reconnect', onReconnect);
        return () => socket.io.off('reconnect', onReconnect);
      }, [socket, g.roomId, g.playerId]);

      // Clean up WebRTC on rematch
      useEffect(() => {
        if (g.screen === 'capture-pint' && g.isRematch) {
          webrtc.cleanup();
        }
      }, [g.screen, g.isRematch]);

      const handleLeaveRoom = useCallback(() => {
        webrtc.cleanup();
        if (socket) socket.emit('leave-room');
        dispatch({ type: 'LEAVE_ROOM' });
      }, [socket, webrtc]);

      // ---- Socket events ----
      useEffect(() => {
        if (!socket) return;

        const onMatched = (data) => {
          dispatch({ type: 'MATCHED', roomId: data.roomId, playerId: data.playerId, opponentId: data.opponentId, opponentName: data.opponentName, isInitiator: data.isInitiator, opponentPintImage: data.opponentPintImage, mode: data.mode });
        };

        const onReadyUpdate = (data) => {
          const myId = socket.id;
          const oppId = Object.keys(data.readyState).find(id => id !== myId);
          dispatch({ type: 'READY_UPDATE', myReady: data.readyState[myId], opponentReady: oppId ? data.readyState[oppId] : false });
        };

        const onGameStart = (data) => {
          // Handle both initial game start and next-round start
          if (screenRef.current === 'reveal') {
            // Next round in best-of-3
            dispatch({ type: 'NEXT_ROUND', countdownStart: data.countdownStart });
          } else {
            dispatch({ type: 'GAME_START', countdownStart: data.countdownStart });
          }
        };

        const onOpponentSubmitted = (data) => {
          dispatch({ type: 'OPPONENT_SUBMITTED', timeoutEnd: data && data.timeoutEnd ? data.timeoutEnd : null });
        };

        const onSubmitAck = (data) => {
          if (data && data.timeoutEnd) dispatch({ type: 'SET_TIMEOUT_END', timeoutEnd: data.timeoutEnd });
        };

        const onRevealStart = (data) => {
          dispatch({ type: 'REVEAL_START', data });
        };

        const onServerError = (data) => {
          showToast(data && data.message ? data.message : 'Server error', 'error');
        };

        const onRejoinSuccess = () => {
          showToast('Reconnected to game');
        };

        const onRejoinFailed = () => {
          showToast('Failed to rejoin game', 'error');
          handleLeaveRoom();
        };

        const onRematchRequested = () => dispatch({ type: 'SET_REMATCH_STATE', pending: true });

        const onRematchAccepted = () => {
          dispatch({ type: 'REMATCH_ACCEPTED' });
        };

        const onRematchDeclined = () => {
          dispatch({ type: 'SET_REMATCH_STATE', requested: false });
          showToast('Opponent declined rematch', 'error');
        };

        const handleOpponentGone = (label) => {
          const s = screenRef.current;
          const activeScreens = ['countdown', 'capture-result', 'drinking'];
          if (activeScreens.includes(s)) {
            dispatch({ type: 'SET_SOLO_CONTINUE' });
            showToast(`${label} \u2014 continuing solo`);
            return;
          }
          if (s === 'waiting' && myResultRef.current) {
            dispatch({ type: 'SET_SOLO_CONTINUE' });
            recordGame({ outcome: 'win', accuracy: myResultRef.current.accuracy });
            showToast(`${label} \u2014 you win!`);
            dispatch({ type: 'SET_SCREEN', screen: 'solo-reveal' });
            return;
          }
          showToast(label, 'error');
          handleLeaveRoom();
        };

        const onOpponentDisconnected = () => handleOpponentGone('Opponent disconnected');
        const onOpponentLeft = () => handleOpponentGone('Opponent left the game');

        socket.on('matched', onMatched);
        socket.on('ready-update', onReadyUpdate);
        socket.on('game-start', onGameStart);
        socket.on('opponent-submitted', onOpponentSubmitted);
        socket.on('submit-ack', onSubmitAck);
        socket.on('reveal-start', onRevealStart);
        socket.on('rematch-requested', onRematchRequested);
        socket.on('rematch-accepted', onRematchAccepted);
        socket.on('rematch-declined', onRematchDeclined);
        socket.on('opponent-disconnected', onOpponentDisconnected);
        socket.on('opponent-left', onOpponentLeft);
        socket.on('error', onServerError);
        socket.on('rejoin-success', onRejoinSuccess);
        socket.on('rejoin-failed', onRejoinFailed);

        return () => {
          socket.off('matched', onMatched);
          socket.off('ready-update', onReadyUpdate);
          socket.off('game-start', onGameStart);
          socket.off('opponent-submitted', onOpponentSubmitted);
          socket.off('submit-ack', onSubmitAck);
          socket.off('reveal-start', onRevealStart);
          socket.off('rematch-requested', onRematchRequested);
          socket.off('rematch-accepted', onRematchAccepted);
          socket.off('rematch-declined', onRematchDeclined);
          socket.off('opponent-disconnected', onOpponentDisconnected);
          socket.off('opponent-left', onOpponentLeft);
          socket.off('error', onServerError);
          socket.off('rejoin-success', onRejoinSuccess);
          socket.off('rejoin-failed', onRejoinFailed);
        };
      }, [socket, showToast, handleLeaveRoom]);

      // Start WebRTC when matched
      useEffect(() => {
        if (g.screen === 'matched' && socket && g.opponentId) {
          webrtc.start();
        }
      }, [g.screen, socket, g.opponentId]);

      // ---- Handlers ----
      const handleGetStarted = () => dispatch({ type: 'SET_SCREEN', screen: 'capture-pint' });

      const handleQuickPlay = () => {
        dispatch({ type: 'SET_SCREEN', screen: 'searching' });
        if (socket) socket.emit('join-queue', { nickname: nickname || 'Anon', mode: preferredMode });
      };

      const handleSoloMode = useCallback(() => {
        if (socket) socket.emit('leave-queue');
        dispatch({ type: 'SET_SOLO_MODE', gameStartTime: Date.now() + 3000 });
        showToast('Solo mode activated', 'info');
      }, [socket, showToast]);

      const handlePintCaptured = async (img) => {
        dispatch({ type: 'SET_PINT_IMAGE', image: img });
        dispatch({ type: 'SET_SCREEN', screen: 'searching' });
        const compressed = await compressImage(img);
        if (socket) {
          socket.emit('submit-pint-image', { image: compressed });
          socket.emit('join-queue', { nickname: nickname || 'Anon', mode: preferredMode });
        }
      };

      const handleCancelSearch = () => {
        if (socket) socket.emit('leave-queue');
        dispatch({ type: 'SET_PINT_IMAGE', image: null });
        dispatch({ type: 'SET_SCREEN', screen: 'landing' });
      };

      const handleMatchedContinue = () => dispatch({ type: 'SET_SCREEN', screen: 'ready' });

      const handleReady = () => {
        if (socket) socket.emit('player-ready');
        dispatch({ type: 'SET_MY_READY' });
      };

      const handleDrinkingDone = useCallback(() => dispatch({ type: 'SET_SCREEN', screen: 'capture-result' }), []);

      const handleResultCaptured = async (img) => {
        dispatch({ type: 'SET_CAPTURED_RESULT', image: img, isScanning: true });

        // Wait for scan animation, then analyze
        setTimeout(async () => {
          const canvas = canvasRef.current;
          const analysis = await analyze(img, canvas);
          dispatch({ type: 'SET_SCANNING', isScanning: false });
          dispatch({ type: 'SET_MY_RESULT', result: { ...analysis, image: img } });

          if (soloModeRef.current) {
            const outcome = analysis.accuracy >= 50 ? 'win' : 'loss';
            recordGame({ outcome, accuracy: analysis.accuracy });
            leaderboard.addEntry(nickname || 'Anon', analysis.accuracy);
            dispatch({ type: 'SET_SCREEN', screen: 'solo-reveal' });
          } else {
            const compressed = await compressImage(img);
            if (socket) socket.emit('submit-result', { image: compressed, accuracy: analysis.accuracy });
            dispatch({ type: 'SET_SCREEN', screen: 'waiting' });
          }
        }, 1800);
      };

      const handleRematch = () => {
        dispatch({ type: 'SET_REMATCH_STATE', requested: true });
        if (socket) socket.emit('request-rematch');
      };

      const handleAcceptRematch = () => {
        if (socket) socket.emit('accept-rematch');
      };

      const handleDeclineRematch = () => {
        if (socket) socket.emit('decline-rematch');
        dispatch({ type: 'SET_REMATCH_STATE', pending: false });
      };

      const handleNextRound = () => {
        if (socket) socket.emit('next-round-ready');
      };

      const handleCancelRematch = () => {
        dispatch({ type: 'SET_REMATCH_STATE', requested: false });
      };

      const handleNewOpponent = () => {
        handleLeaveRoom();
        setTimeout(() => {
          dispatch({ type: 'SET_SCREEN', screen: 'capture-pint' });
        }, 100);
      };

      const handleSoloPlayAgain = () => {
        dispatch({ type: 'SOLO_PLAY_AGAIN', gameStartTime: Date.now() + 3000 });
      };

      const handleSoloHome = () => {
        dispatch({ type: 'SOLO_HOME' });
      };

      return (
        <div style={{ minHeight: '100vh' }}>
          <LandscapeWarning />
          <canvas ref={canvasRef} style={{ display: 'none' }} />
          <Toast message={toastMsg} type={toastType} visible={toastVisible} />
          <ConnectionBanner connected={connected} />

          <AnimatePresence mode="wait">
            {g.screen === 'landing' && (
              <LandingScreen key="landing" onStart={handleGetStarted} onQuickPlay={handleQuickPlay} stats={stats} winRate={winRate}
                nickname={nickname} onSetNickname={setNickname} leaderboardEntries={leaderboard.entries} />
            )}

            {g.screen === 'capture-pint' && (
              <CaptureScreen key="capture-pint" mode="full-pint" onCapture={handlePintCaptured} onCancel={() => dispatch({ type: 'SET_SCREEN', screen: 'landing' })} />
            )}

            {g.screen === 'searching' && (
              <SearchingScreen key="searching" onCancel={handleCancelSearch} onSolo={handleSoloMode} pintThumbnail={g.pintImage} />
            )}

            {g.screen === 'matched' && (
              <MatchedScreen key="matched"
                localStream={webrtc.localStream}
                remoteStream={webrtc.remoteStream}
                connectionState={webrtc.connectionState}
                webrtcError={webrtc.error}
                onRetryWebRTC={webrtc.retry}
                onReady={handleMatchedContinue}
                isMuted={webrtc.isMuted}
                onToggleMute={webrtc.toggleMute}
                opponentPintImage={g.opponentPintImage} />
            )}

            {g.screen === 'ready' && (
              <ReadyScreen key="ready"
                localStream={webrtc.localStream}
                remoteStream={webrtc.remoteStream}
                myReady={g.myReady}
                opponentReady={g.opponentReady}
                onReady={handleReady}
                isMuted={webrtc.isMuted}
                onToggleMute={webrtc.toggleMute} />
            )}

            {g.screen === 'countdown' && (
              <CountdownScreen key="countdown"
                gameStartTime={g.gameStartTime}
                remoteStream={webrtc.remoteStream}
                onDone={handleDrinkingDone}
                soloMode={g.soloMode}
                soloFallback={g.soloFallback}
                isMuted={webrtc.isMuted}
                onToggleMute={webrtc.toggleMute} />
            )}

            {g.screen === 'capture-result' && (
              <CaptureScreen key="capture-result" mode="result"
                onCapture={handleResultCaptured}
                capturedImage={g.capturedResultImage}
                isScanning={g.isScanning}
                remoteStream={!g.soloMode ? webrtc.remoteStream : null} />
            )}

            {g.screen === 'waiting' && (
              <WaitingScreen key="waiting"
                accuracy={g.myResult?.accuracy ?? null}
                resultImage={g.myResult?.image}
                remoteStream={webrtc.remoteStream}
                opponentSubmitted={g.opponentSubmitted}
                timeoutEnd={g.timeoutEnd} />
            )}

            {g.screen === 'reveal' && g.revealData && (
              <RevealScreen key="reveal"
                revealData={{...g.revealData, opponentName: g.opponentName}}
                playerId={g.playerId}
                onRematch={handleRematch}
                onNewOpponent={handleNewOpponent}
                onCancelRematch={handleCancelRematch}
                rematchRequested={g.rematchRequested}
                rematchPending={g.rematchPending}
                onAcceptRematch={handleAcceptRematch}
                onDeclineRematch={handleDeclineRematch}
                stats={stats}
                winRate={winRate}
                isRematch={g.isRematch}
                seriesData={g.seriesData}
                onNextRound={handleNextRound} />
            )}

            {g.screen === 'solo-reveal' && g.myResult && (
              <SoloRevealScreen key="solo-reveal"
                accuracy={g.myResult.accuracy}
                resultImage={g.myResult.image}
                onPlayAgain={handleSoloPlayAgain}
                onHome={handleSoloHome}
                stats={stats}
                winRate={winRate} />
            )}
          </AnimatePresence>
        </div>
      );
    }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
    const splash = document.getElementById('splash');
    if (splash) splash.remove();
  </script>
</body>
</html>
